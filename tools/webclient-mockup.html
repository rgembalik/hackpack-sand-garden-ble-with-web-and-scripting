<!DOCTYPE html>
<html lang="en" class="h-full">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sand Garden Controller (Mockup)</title>
  <!-- TailwindCSS v4 CDN (placeholder; update if hash changes) -->
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  <script>
    // Tailwind config (runtime) – custom colors & fonts
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            sg: {
              bg: '#0d0d0f',
              panel: '#16171b',
              accent: '#ff7a00', // orange screw color
              accentAlt: '#ff9d3d',
              ring: '#ffffff'
            }
          },
          boxShadow: {
            'inner-glow': 'inset 0 0 8px rgba(255,122,0,0.4)',
            'sand': '0 0 0 2px #ffffff10, 0 0 12px 4px #ffffff08 inset'
          }
        }
      }
    }
  </script>
  <!-- Alpine.js for lightweight reactivity -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    /* Scrollbar theming */
    ::-webkit-scrollbar {
      width: 10px;
    }

    ::-webkit-scrollbar-track {
      background: #111;
    }

    ::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 6px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #444;
    }

    /* Screw indicators */
    .sg-screw {
      width: 18px;
      height: 18px;
      border: 2px solid #ff7a00;
      border-radius: 50%;
      position: absolute;
      box-shadow: 0 0 6px 2px rgba(255, 122, 0, 0.35), inset 0 0 4px rgba(255, 122, 0, 0.4);
    }

    .sg-screw::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 2px;
      background: #ff7a00;
      transform: translate(-50%, -50%);
    }

    /* Circle (sand tray) */
    .sand-tray {
      aspect-ratio: 1/1;
      border: 4px solid #fff;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 50%, #ffffff 0%, #d9d9d9 55%, #cfcfcf 70%, #bfbfbf 90%);
      position: relative;
    }

    .tray-overlay {
      position: absolute;
      inset: 0;
      mix-blend-mode: multiply;
      pointer-events: none;
    }

    .pattern-canvas {
      width: 100%;
      height: 100%;
      border-radius: 50%;
    }
  </style>
</head>

<body class="h-full bg-sg-bg text-gray-100 font-sans antialiased">
  <div class="min-h-full flex flex-col" x-data="sandGardenApp()" x-init="init()">
    <!-- Header -->
    <header class="px-6 py-4 border-b border-gray-700/40 flex items-center gap-6 bg-sg-panel/70 backdrop-blur-md">
      <div class="flex items-center gap-3">
        <div class="relative w-10 h-10">
          <div
            class="absolute inset-0 rounded-full bg-gradient-to-br from-sg-accent to-sg-accentAlt blur-sm opacity-70">
          </div>
          <div
            class="relative inset-0 w-full h-full rounded-full flex items-center justify-center bg-sg-panel text-sg-accent font-bold tracking-wider">
            SG</div>
        </div>
        <h1 class="text-xl font-semibold tracking-wide">Sand Garden Controller <span
            class="text-sg-accent text-base font-medium">Mockup</span></h1>
      </div>
      <div class="flex-1"></div>
      <div class="flex items-center gap-4">
        <button @click="toggleRun()"
          :class="running ? 'bg-red-600 hover:bg-red-500' : 'bg-sg-accent hover:bg-sg-accent/80'"
          class="px-4 py-2 rounded-md font-medium transition shadow-inner-glow focus:outline-none focus:ring-2 focus:ring-sg-accent/60">
          <span x-text="running ? 'Stop' : 'Run'"></span> </button>
        <button @click="connect()"
          class="px-4 py-2 rounded-md bg-gray-700 hover:bg-gray-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-sg-accent/60"
          :disabled="connecting || connected" :class="(connecting||connected) ? 'opacity-60 cursor-not-allowed' : ''">
          <span x-show="!connected && !connecting">Connect</span>
          <span x-show="connecting">Connecting...</span>
          <span x-show="connected">Connected</span>
        </button>
        <button x-show="!connected && device && !connecting" @click="reconnect()"
          class="px-4 py-2 rounded-md bg-gray-700 hover:bg-gray-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-sg-accent/60">Reconnect</button>
      </div>
    </header>

    <!-- Main Layout -->
    <main class="flex-1 grid xl:grid-cols-3 gap-6 p-6">
      <!-- Left Column: Status & Config -->
      <section class="space-y-6">
        <!-- Device Status -->
        <div class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow relative">
          <h2 class="text-lg font-semibold mb-3 flex items-center gap-2">Device Status
            <span class="inline-flex items-center" :class="connected ? 'text-green-400' : 'text-gray-400'">
              <span class="w-2.5 h-2.5 rounded-full mr-1"
                :class="connected ? 'bg-green-400 animate-pulse' : 'bg-gray-500' "></span>
              <span x-text="connected ? 'Online' : 'Offline'"></span>
            </span>
          </h2>
          <dl class="text-sm grid grid-cols-2 gap-x-6 gap-y-2">
            <div>
              <dt class="text-gray-400">Speed Multiplier</dt>
              <dd class="font-mono" x-text="speedMultiplier.toFixed(2)"></dd>
            </div>
            <div>
              <dt class="text-gray-400">Mode</dt>
              <dd class="font-mono" x-text="autoMode ? 'Automatic' : 'Manual'"></dd>
            </div>
            <div>
              <dt class="text-gray-400">Pattern</dt>
              <dd class="font-mono" x-text="pattern + ' - ' + patternMeta[pattern-1].name"></dd>
            </div>
            <div>
              <dt class="text-gray-400">Running</dt>
              <dd class="font-mono" x-text="running ? 'Yes' : 'No'"></dd>
            </div>
          </dl>
          <div class="mt-4 text-xs text-gray-400" x-text="statusMessage"></div>
        </div>

        <!-- Configuration -->
        <form @submit.prevent
          class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow space-y-5">
          <h2 class="text-lg font-semibold mb-1">Configuration</h2>
          <div>
            <label for="speedMultiplier" class="block text-sm font-medium mb-1">Speed Multiplier <span
                class="text-gray-500">(0.1 - 3.0)</span></label>
            <div class="flex items-center gap-3">
              <input id="speedMultiplier" type="range" min="0.1" max="3" step="0.1" x-model.number="speedMultiplier"
                @input="debouncedSendSpeed()" class="w-full accent-sg-accent" />
              <input type="number" step="0.1" min="0.1" max="3" x-model.number="speedMultiplier" @change="sendSpeed()"
                class="w-20 bg-gray-800 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-sg-accent/50" />
            </div>
          </div>
          <div class="flex items-center gap-4">
            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
              <input type="checkbox" x-model="autoMode" @change="sendMode()"
                class="rounded bg-gray-800 border-gray-600 text-sg-accent focus:ring-sg-accent/60" />
              <span class="text-sm">Automatic Mode</span>
            </label>
            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
              <input type="checkbox" x-model="showTrails"
                class="rounded bg-gray-800 border-gray-600 text-sg-accent focus:ring-sg-accent/60" />
              <span class="text-sm">Show Trails</span>
            </label>
          </div>
          <div class="flex gap-3">
            <button type="button" @click="centerView()"
              class="px-3 py-2 rounded-md bg-gray-700 hover:bg-gray-600 text-sm font-medium">Center View</button>
            <button type="button" @click="clearPattern()"
              class="px-3 py-2 rounded-md bg-gray-700 hover:bg-gray-600 text-sm font-medium">Clear Pattern</button>
          </div>
        </form>

        <!-- Logs -->
        <div
          class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow flex flex-col h-64">
          <h2 class="text-lg font-semibold mb-2">Event Log</h2>
          <div class="flex-1 overflow-auto text-xs space-y-1 leading-relaxed font-mono" x-ref="log">
            <template x-for="(line, idx) in logs" :key="idx">
              <div class="text-gray-400" x-text="line"></div>
            </template>
          </div>
          <div class="pt-2 flex justify-end">
            <button @click="logs=[]" class="text-xs text-sg-accent hover:underline">Clear</button>
          </div>
        </div>
      </section>

      <!-- Middle: Pattern Selection -->
      <section class="space-y-6">
        <div class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow">
          <h2 class="text-lg font-semibold mb-4">Patterns</h2>
          <ul class="grid sm:grid-cols-2 gap-3">
            <template x-for="p in patternMeta" :key="p.id">
              <li>
                <button @click="selectPattern(p.id)"
                  :class="pattern === p.id ? 'ring-2 ring-sg-accent/70 bg-sg-accent/10' : 'hover:bg-gray-700/50'"
                  class="w-full text-left px-3 py-2 rounded-lg bg-gray-800/40 border border-gray-700/60 transition duration-150 focus:outline-none focus:ring-2 focus:ring-sg-accent/50">
                  <div class="flex justify-between items-center">
                    <span class="font-medium" x-text="p.id + '. ' + p.name"></span>
                    <span class="text-xs text-gray-400" x-text="p.short"></span>
                  </div>
                </button>
              </li>
            </template>
          </ul>
        </div>

        <div class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow">
          <h2 class="text-lg font-semibold mb-3">Pattern Details</h2>
          <div class="text-sm text-gray-300" x-text="patternMeta[pattern-1].description"></div>
        </div>

      </section>

      <!-- Right: Visualizer -->
      <section class="space-y-6">
        <div class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow relative">
          <h2 class="text-lg font-semibold mb-3">Visualizer</h2>
          <div class="relative">
            <!-- Screws around tray -->
            <div class="sg-screw" style="top:-12px; left:50%; transform:translateX(-50%);"></div>
            <div class="sg-screw" style="bottom:-12px; left:50%; transform:translateX(-50%);"></div>
            <div class="sg-screw" style="left:-12px; top:50%; transform:translateY(-50%);"></div>
            <div class="sg-screw" style="right:-12px; top:50%; transform:translateY(-50%);"></div>
            <div class="sand-tray shadow-sand" x-ref="tray">
              <canvas x-ref="canvas" class="pattern-canvas"></canvas>
              <div class="tray-overlay rounded-full pointer-events-none"></div>
            </div>
          </div>
          <div class="mt-4 flex flex-wrap gap-3 text-xs">
            <button @click="regeneratePattern()"
              class="px-3 py-1.5 rounded bg-gray-700 hover:bg-gray-600">Regenerate</button>
            <button @click="toggleSimulation()" class="px-3 py-1.5 rounded bg-gray-700 hover:bg-gray-600"
              x-text="simulationRunning ? 'Pause' : 'Play'"></button>
            <button @click="exportImage()" class="px-3 py-1.5 rounded bg-gray-700 hover:bg-gray-600">Export</button>
            <label class="inline-flex items-center gap-1 cursor-pointer select-none ml-auto">
              <input type="checkbox" x-model="showTrails" @change="onShowTrailsChange()"
                class="rounded bg-gray-800 border-gray-600 text-sg-accent focus:ring-sg-accent/60" />
              <span>Show Trails</span>
            </label>
          </div>
        </div>
      </section>
    </main>

    <footer class="px-6 py-3 text-xs text-gray-500 flex justify-between border-t border-gray-800 bg-sg-panel/60">
      <div>Sand Garden UI Mockup – Firmware integration TBD.</div>
      <div>Colors: Device Black + Orange Screws + White Sand</div>
    </footer>
  </div>

  <script>
    function sandGardenApp() {
      return {
        // State
        connected: false,
        connecting: false,
        running: false,
        autoMode: true,
        speedMultiplier: 1.0,
        pattern: 1,
        showTrails: true,
        statusMessage: 'Idle',
        logs: [],
        device: null, server: null,
        chars: { speed: null, pattern: null, status: null, mode: null, run: null, telemetry: null },
        // Telemetry state
        joy: { a: 0, r: 0, mag: 0 }, lastState: { pat: null, auto: null, run: null, brt: null }, heartbeatCount: 0,
        patternMeta: [
          // Added pointsTarget to guide simulation length (approx, can tweak)
          { id: 1, name: 'Simple Spiral', short: 'spiral', description: 'Outward then inward spiral path (firmware logic).', pointsTarget: 4500 },
          { id: 2, name: 'Cardioids', short: 'cardioid', description: 'Petaled cardioid style looping figure.', pointsTarget: 1200 },
          { id: 3, name: 'Wavy Spiral', short: 'wavy', description: 'Spiral with sinusoidal radial modulation.', pointsTarget: 4600 },
          { id: 4, name: 'Rotating Squares', short: 'squares', description: 'Sequence of rotating square outlines.', pointsTarget: 2300 },
          { id: 5, name: 'Pentagon Spiral', short: 'penta sp', description: 'Pentagon-based growing & shrinking spiral.', pointsTarget: 3200 },
          { id: 6, name: 'Hexagon Vortex', short: 'hexa', description: 'Rotating, pulsing hexagon vortex.', pointsTarget: 3000 },
          { id: 7, name: 'Pentagon Rainbow', short: 'penta rb', description: 'Off-center rotating/translated pentagon.', pointsTarget: 2500 },
          { id: 8, name: 'Random Walk 1', short: 'rw arc', description: 'Random absolute targets (shortest angular path).', pointsTarget: 1800 },
          { id: 9, name: 'Random Walk 2', short: 'rw line', description: 'Random straight-line interpolation between points.', pointsTarget: 1800 },
          { id: 10, name: 'Accidental Butterfly', short: 'butterfly', description: 'Sinusoidally modulated spiral (butterfly).', pointsTarget: 4600 }
        ],
        // Drawing
  canvas: null, ctx: null, traySize: 0, points: [],
  // Ball & trench visualization (direct stamping; no offscreen accumulation)
  ballRadiusPx: 6, trenchDepth: 1.0, trenchSoftness: 8,
  lastHeadX: null, lastHeadY: null, trenchStampSpacingFactor: 0.55, // spacing = ballRadiusPx * factor
  trailInitialized: false, ballPrevImage: null, ballPrevBox: null,
        // simulation timing (distance based)
        simulationRunning: false, linearSpeed: 300, lastTs: 0,
        simulationDistance: 0, totalPathLength: 0,
        segmentLengths: [], segmentEndDistances: [], segmentIndex: 0,
        segmentPolar: [], // per segment polar interpolation data {r0,r1,dr,theta0,theta1,dθ,length}
        pointsPolar: [], // derived polar coordinates for each point (r, theta)
        // path accumulation
        pathCanvas: null, pathCtx: null, lastDrawnSegmentIndex: 0,
        init() {
          this.canvas = this.$refs.canvas;
          this.ctx = this.canvas.getContext('2d');
          this.resizeCanvas();
          window.addEventListener('resize', () => this.resizeCanvas());
          this.regeneratePattern();
          this.log('UI initialized');
        },
        resizeCanvas() {
          const rect = this.$refs.tray.getBoundingClientRect();
          const size = Math.min(rect.width, rect.height);
          this.canvas.width = size; this.canvas.height = size; this.traySize = size;
          this.ensurePathBuffer();
          this.clearPath();
          this.renderFrame();
        },
        log(msg) {
          const t = new Date().toLocaleTimeString();
          this.logs.push(`[${t}] ${msg}`);
          this.$nextTick(() => {
            const el = this.$refs.log; el.scrollTop = el.scrollHeight;
          });
        },
        setStatus(s) { this.statusMessage = s; this.log(s); },
        async connect() {
          if (!navigator.bluetooth) { this.setStatus('Web Bluetooth not supported'); return; }
          if (this.connected || this.connecting) return;
          this.connecting = true; this.setStatus('Requesting Sand Garden device...');
          // UUIDs from firmware BLEConfigServer.h
          const SERVICE_UUID = '9b6c7e10-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const SPEED_UUID = '9b6c7e11-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const PATTERN_UUID = '9b6c7e12-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const STATUS_UUID = '9b6c7e13-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const MODE_UUID = '9b6c7e14-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const RUN_UUID = '9b6c7e15-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const TELEMETRY_UUID = '9b6c7e16-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const COMMAND_UUID = '9b6c7e17-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          try {
            this.device = await navigator.bluetooth.requestDevice({
              filters: [{ services: [SERVICE_UUID] }],
              optionalServices: [SERVICE_UUID]
            });
            this.device.addEventListener('gattserverdisconnected', () => { this.onDisconnect(); });
            this.setStatus('Connecting GATT...');
            this.server = await this.device.gatt.connect();
            const service = await this.server.getPrimaryService(SERVICE_UUID);
            this.setStatus('Discovering characteristics...');
            const speedChar = await service.getCharacteristic(SPEED_UUID);
            const patternChar = await service.getCharacteristic(PATTERN_UUID);
            const statusChar = await service.getCharacteristic(STATUS_UUID);
            // Mode/run are optional until firmware updated; wrap in try
            let modeChar = null, runChar = null, telemetryChar = null;
            try { modeChar = await service.getCharacteristic(MODE_UUID); } catch (_) { }
            try { runChar = await service.getCharacteristic(RUN_UUID); } catch (_) { }
            try { telemetryChar = await service.getCharacteristic(TELEMETRY_UUID); } catch (_) { this.log('Telemetry characteristic not found (firmware older?)'); }
            this.chars = { speed: speedChar, pattern: patternChar, status: statusChar, mode: modeChar, run: runChar, telemetry: telemetryChar };
            // Initial reads
            await this.readInitialValues();
            // Notifications
            await Promise.all([
              speedChar.startNotifications().then(() => {
                speedChar.addEventListener('characteristicvaluechanged', e => { this.handleSpeedNotify(e); });
              }),
              patternChar.startNotifications().then(() => {
                patternChar.addEventListener('characteristicvaluechanged', e => { this.handlePatternNotify(e); });
              }),
              statusChar.startNotifications().then(() => {
                statusChar.addEventListener('characteristicvaluechanged', e => { this.handleStatusNotify(e); });
              }),
              modeChar && modeChar.startNotifications().then(() => {
                modeChar.addEventListener('characteristicvaluechanged', e => { this.handleModeNotify(e); });
              }).catch(() => { }),
              runChar && runChar.startNotifications().then(() => {
                runChar.addEventListener('characteristicvaluechanged', e => { this.handleRunNotify(e); });
              }).catch(() => { }),
              telemetryChar && telemetryChar.startNotifications().then(() => {
                telemetryChar.addEventListener('characteristicvaluechanged', e => { this.handleTelemetryNotify(e); });
              }).catch(() => { })
            ]);
            this.connected = true; this.setStatus('Connected');
            this.log('BLE ready.');
          } catch (err) {
            this.setStatus('Connection failed: ' + err.message);
            this.log('Error: ' + err.stack);
          } finally { this.connecting = false; }
        },
        async readInitialValues() {
          // Firmware sends ASCII; parse accordingly
          try {
            if (this.chars.speed) {
              const v = await this.chars.speed.readValue();
              const txt = this.textFromDV(v); const num = parseFloat(txt); if (!isNaN(num)) this.speedMultiplier = num;
            }
            if (this.chars.pattern) {
              const v = await this.chars.pattern.readValue();
              const txt = this.textFromDV(v); const num = parseInt(txt); if (!isNaN(num)) this.pattern = num;
            }
            if (this.chars.status) {
              const v = await this.chars.status.readValue();
              this.statusMessage = this.textFromDV(v);
            }
            if (this.chars.mode) {
              const v = await this.chars.mode.readValue();
              const txt = this.textFromDV(v); const num = parseInt(txt); this.autoMode = (num === 1);
            }
            if (this.chars.run) {
              const v = await this.chars.run.readValue();
              const txt = this.textFromDV(v); const num = parseInt(txt); this.running = (num === 1);
            }
          } catch (e) { this.log('Read init failed: ' + e.message); }
        },
        // Notification handlers
        handleSpeedNotify(e) { const txt = this.textFromDV(e.target.value); const num = parseFloat(txt); if (!isNaN(num)) { this.speedMultiplier = num; this.log('Speed->' + num.toFixed(3)); } },
        handlePatternNotify(e) { const txt = this.textFromDV(e.target.value); const num = parseInt(txt); if (!isNaN(num)) { this.pattern = num; this.regeneratePattern(); this.log('Pattern->' + num); } },
        handleStatusNotify(e) { const txt = this.textFromDV(e.target.value); this.setStatus(txt); },
        handleModeNotify(e) { const txt = this.textFromDV(e.target.value); const num = parseInt(txt); this.autoMode = (num === 1); this.log('Mode->' + (this.autoMode ? 'Auto' : 'Manual')); },
        handleRunNotify(e) { const txt = this.textFromDV(e.target.value); const num = parseInt(txt); this.running = (num === 1); this.log('Run->' + (this.running ? 'Running' : 'Stopped')); },
        handleTelemetryNotify(e) {
          const txt = this.textFromDV(e.target.value);
          // Expect lines like: JOY a=12 r=-3 mag=12 | STATE pat=1 auto=1 run=1 brt=40 | HB
          if (txt.startsWith('JOY ')) {
            const parts = Object.fromEntries(txt.substring(4).split(/\s+/).map(kv => kv.split('=')));
            const a = parseInt(parts.a) || 0; const r = parseInt(parts.r) || 0; const mag = parseInt(parts.mag) || Math.max(Math.abs(a), Math.abs(r));
            this.joy = { a, r, mag };
            this.log(`JOY a=${a} r=${r} mag=${mag}`);
          } else if (txt.startsWith('STATE ')) {
            const parts = Object.fromEntries(txt.substring(6).split(/\s+/).map(kv => kv.split('=')));
            const pat = parseInt(parts.pat); const auto = parts.auto === '1'; const run = parts.run === '1'; const brt = parseInt(parts.brt);
            this.lastState = { pat, auto, run, brt };
            // Optionally sync if drifted
            if (!isNaN(pat) && pat !== this.pattern) this.pattern = pat;
            if (typeof auto === 'boolean' && auto !== this.autoMode) this.autoMode = auto;
            if (typeof run === 'boolean' && run !== this.running) this.running = run;
          } else if (txt === 'HB') {
            this.heartbeatCount++; this.log('HB ' + this.heartbeatCount);
          } else {
            this.log('TL ' + txt);
          }
        },
        textFromDV(dv) { let str = ''; for (let i = 0; i < dv.byteLength; i++) { const c = dv.getUint8(i); if (c === 0) break; str += String.fromCharCode(c); } return str.trim(); },
        toggleRun() { this.running = !this.running; this.sendRun(); },
        debouncedSendSpeed: debounce(function () { this.sendSpeed(); }, 400),
        async sendSpeed() {
          this.setStatus('Speed multiplier -> ' + this.speedMultiplier.toFixed(2));
          if (this.chars.speed) {
            try { const txt = new TextEncoder().encode(this.speedMultiplier.toFixed(3)); await this.chars.speed.writeValue(txt); }
            catch (e) { this.log('Speed write err: ' + e.message); }
          }
        },
        async sendMode() {
          this.setStatus('Mode -> ' + (this.autoMode ? 'Automatic' : 'Manual'));
          if (this.chars.mode) {
            try { const txt = new TextEncoder().encode(this.autoMode ? '1' : '0'); await this.chars.mode.writeValue(txt); }
            catch (e) { this.log('Mode write err: ' + e.message); }
          }
        },
        async sendRun() {
          this.setStatus(this.running ? 'Pattern running' : 'Pattern stopped');
          if (this.chars.run) {
            try { const txt = new TextEncoder().encode(this.running ? '1' : '0'); await this.chars.run.writeValue(txt); }
            catch (e) { this.log('Run write err: ' + e.message); }
          }
        },
        // Removed runLedSelfTest / sendCommand / direct LED color helpers (unsupported)
        async disconnectDevice() {
          if (this.device && this.device.gatt && this.device.gatt.connected) {
            try { this.device.gatt.disconnect(); this.setStatus('Disconnected'); } catch (e) { this.log('Disconnect err: ' + e.message); }
          }
          this.connected = false;
        },
        async reconnect() { if (!this.device) { return this.connect(); } if (this.connected || this.connecting) return; try { this.connecting = true; this.setStatus('Reconnecting...'); await this.device.gatt.connect(); this.connecting = false; await this.connect(); } catch (e) { this.connecting = false; this.setStatus('Reconnect failed: ' + e.message); } },
        async selectPattern(id) {
          this.pattern = id; this.setStatus('Selected pattern ' + id); this.regeneratePattern();
          if (this.chars.pattern) {
            try { const txt = new TextEncoder().encode(String(id)); await this.chars.pattern.writeValue(txt); }
            catch (e) { this.log('Pattern write err: ' + e.message); }
          }
        },
        regeneratePattern() {
          this.points = this.generatePatternPoints(this.pattern);
          this.computePathMetrics();
          this.simulationDistance = 0; this.segmentIndex = 0; this.lastDrawnSegmentIndex = 0;
          this.resetTrail();
          this.drawBackground();
          this.renderFrame();
        },
        clearPattern() { this.points = []; this.resetTrail(); this.drawBackground(); this.renderFrame(); },
        resetTrail() { this.lastHeadX = null; this.lastHeadY = null; this.trailInitialized = false; this.ballPrevImage = null; this.ballPrevBox = null; },
        centerView() { this.renderFrame(); },
        toggleSimulation() { this.simulationRunning = !this.simulationRunning; if (this.simulationRunning) { this.lastTs = 0; requestAnimationFrame(this.stepSimulation.bind(this)); } },
        stepSimulation(ts) {
          if (!this.simulationRunning) return;
          if (!this.lastTs) this.lastTs = ts; const dt = (ts - this.lastTs) / 1000; this.lastTs = ts;
          this.simulationDistance += this.linearSpeed * dt;
          if (this.simulationDistance >= this.totalPathLength) {
            this.simulationDistance = 0; this.segmentIndex = 0; this.lastDrawnSegmentIndex = 0; this.clearPath();
            if (this.trenchCtx) this.trenchCtx.clearRect(0,0,this.trenchCanvas.width,this.trenchCanvas.height);
            this.lastHeadX = null; this.lastHeadY = null;
          }
          this.updateSegmentIndex();
          this.updateTrail();
          this.renderFrame();
          requestAnimationFrame(this.stepSimulation.bind(this));
        },
        drawBackground() {
          if (!this.ctx) return; const ctx = this.ctx; const w = this.canvas.width; const h = this.canvas.height; ctx.clearRect(0, 0, w, h);
          const grad = ctx.createRadialGradient(w / 2, h / 2, w * 0.05, w / 2, h / 2, w * 0.5);
          grad.addColorStop(0, '#ffffff'); grad.addColorStop(1, '#cfcfcf');
          ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(w / 2, h / 2, w / 2 - 2, 0, Math.PI * 2); ctx.fill();
        },
        ensurePathBuffer() { /* offscreen path buffer removed */ },
        clearPath() { if (this.pathCtx) { this.pathCtx.clearRect(0, 0, this.pathCanvas.width, this.pathCanvas.height); this.lastDrawnSegmentIndex = 0; } },
        computePathMetrics() {
          this.segmentLengths = []; this.segmentEndDistances = []; this.segmentPolar = []; this.pointsPolar = []; this.totalPathLength = 0;
          const n = this.points.length; if (n < 2) return;
          const cx = this.canvas.width / 2; const cy = this.canvas.height / 2;
          // Build polar points (r in pixels, theta in radians)
          for (let i = 0; i < n; i++) {
            const p = this.points[i]; const dx = p.x - cx; const dy = p.y - cy; const r = Math.hypot(dx, dy); let theta = Math.atan2(dy, dx); // [-pi,pi]
            this.pointsPolar.push({ r, theta });
          }
          const tiny = 1e-9;
          function segmentLengthPolar(r0, r1, dr, dθ) {
            const absDr = Math.abs(dr); const absDθ = Math.abs(dθ);
            if (absDr < tiny && absDθ < tiny) return 0;
            if (absDr < tiny) return r0 * absDθ; // pure arc
            if (absDθ < tiny) return absDr; // pure radial
            const k = dr; const B = dθ * dθ; const sqrtB = Math.sqrt(B);
            function G(u) { return 0.5 * (u * Math.sqrt(k * k + B * u * u) + (k * k / sqrtB) * Math.asinh((sqrtB * u) / Math.abs(k))); }
            const L = (G(r1) - G(r0)) / k; return Math.abs(L);
          }
          for (let i = 0; i < n - 1; i++) {
            const p0 = this.pointsPolar[i]; const p1 = this.pointsPolar[i + 1];
            let dθ = p1.theta - p0.theta;
            // Shortest angular difference wrap to [-pi, pi]
            while (dθ > Math.PI) dθ -= 2 * Math.PI; while (dθ < -Math.PI) dθ += 2 * Math.PI;
            const dr = p1.r - p0.r;
            const len = segmentLengthPolar(p0.r, p1.r, dr, dθ);
            this.totalPathLength += len;
            this.segmentLengths.push(len);
            this.segmentEndDistances.push(this.totalPathLength);
            this.segmentPolar.push({ r0: p0.r, r1: p1.r, dr, theta0: p0.theta, theta1: p1.theta, dθ, length: len });
          }
        },
        updateSegmentIndex() {
          // advance segmentIndex until segmentEndDistances[segmentIndex] >= simulationDistance
          while (this.segmentIndex < this.segmentEndDistances.length - 1 && this.segmentEndDistances[this.segmentIndex] < this.simulationDistance) {
            this.segmentIndex++;
          }
        },
        updateTrail() {
          // Incremental stamping now handled inside renderFrame; keep index advance to prevent backlog if jumping
          if (!this.showTrails) return;
          this.lastDrawnSegmentIndex = this.segmentIndex;
        },
        onShowTrailsChange() {
          this.clearPath();
          if (this.showTrails) {
            // rebuild up to current segment
            const prev = this.simulationDistance; this.simulationDistance = 0; this.segmentIndex = 0; this.lastDrawnSegmentIndex = 0;
            // fast-forward drawing
            while (this.segmentIndex < this.segmentEndDistances.length && this.segmentEndDistances[this.segmentIndex] < prev) {
              this.segmentIndex++; this.updateTrail();
            }
            this.simulationDistance = prev; this.updateSegmentIndex(); this.updateTrail();
          }
          this.renderFrame();
        },
        renderFrame() {
          const ctx = this.ctx;
          if (!this.trailInitialized) { this.drawBackground(); this.trailInitialized = true; }
          // Draw head at current simulation index
          if (this.points.length >= 2 && this.segmentPolar.length) {
            const seg = this.segmentPolar[this.segmentIndex];
            if (seg) {
              const segStartDist = this.segmentIndex === 0 ? 0 : this.segmentEndDistances[this.segmentIndex - 1];
              const distWithin = this.simulationDistance - segStartDist;
              // Invert arc-length to get parameter fraction along polar segment
              let t;
              const tiny = 1e-9;
              if (seg.length < tiny) {
                t = 0;
              } else if (Math.abs(seg.dr) < tiny && Math.abs(seg.dθ) > tiny) { // pure arc
                t = distWithin / seg.length;
              } else if (Math.abs(seg.dθ) < tiny && Math.abs(seg.dr) > tiny) { // pure radial
                t = distWithin / seg.length;
              } else {
                // binary search invert lengthAt(t)
                function lengthAt(tt) {
                  // reuse analytic integral via r(t)
                  const r0 = seg.r0; const dr = seg.dr; const dθ = seg.dθ; const k = dr; const B = dθ * dθ; const sqrtB = Math.sqrt(B);
                  function G(u) { return 0.5 * (u * Math.sqrt(k * k + B * u * u) + (k * k / sqrtB) * Math.asinh((sqrtB * u) / Math.abs(k))); }
                  if (Math.abs(dr) < tiny) return r0 * Math.abs(dθ) * tt; // arc
                  const rT = r0 + dr * tt; const L = (G(rT) - G(r0)) / dr; return Math.abs(L);
                }
                let lo = 0, hi = 1; t = 0; const target = distWithin; for (let iter = 0; iter < 18; iter++) { const mid = (lo + hi) / 2; const Lm = lengthAt(mid); if (Lm < target) { lo = mid; } else { hi = mid; } } t = (lo + hi) / 2;
              }
              t = Math.min(1, Math.max(0, t));
              const cx = this.canvas.width / 2; const cy = this.canvas.height / 2;
              const r = seg.r0 + seg.dr * t; const theta = seg.theta0 + seg.dθ * t;
              const hx = cx + r * Math.cos(theta); const hy = cy + r * Math.sin(theta);
              // Incremental stamping directly on main canvas
              if (this.showTrails) {
                const spacing = this.ballRadiusPx * this.trenchStampSpacingFactor;
                const stampSegment = (x0, y0, x1, y1) => {
                  const dx = x1 - x0, dy = y1 - y0; const dist = Math.hypot(dx, dy);
                  if (dist === 0) return;
                  const steps = Math.max(1, Math.floor(dist / spacing));
                  for (let i = 0; i <= steps; i++) {
                    const f = i / steps; const sx = x0 + dx * f; const sy = y0 + dy * f;
                    const trench = ctx;
                    const innerR = this.ballRadiusPx * 0.2;
                    const outerR = this.ballRadiusPx + this.trenchSoftness;
                    const g = trench.createRadialGradient(sx, sy, innerR, sx, sy, outerR);
                    // Trench impression with reduced per-stamp opacity (so overlap builds depth)
                    g.addColorStop(0.0, 'rgba(255,255,255,0.55)');          // reduced center
                    g.addColorStop(0.28, 'rgba(245,245,245,0.38)');
                    g.addColorStop(0.55, 'rgba(230,230,230,0.22)');
                    g.addColorStop(0.75, 'rgba(200,200,200,0.15)');         // subtle mid-band
                    g.addColorStop(0.90, 'rgba(180,180,180,0.10)');         // darker rim hint
                    g.addColorStop(1.0, 'rgba(150,150,150,0)');                // fade out
                    trench.globalCompositeOperation = 'source-over';
                    trench.fillStyle = g;
                    trench.beginPath(); trench.arc(sx, sy, outerR, 0, Math.PI*2); trench.fill();
                  }
                };
                if (this.lastHeadX != null) {
                  stampSegment(this.lastHeadX, this.lastHeadY, hx, hy);
                } else {
                  stampSegment(hx, hy, hx, hy);
                }
                this.lastHeadX = hx; this.lastHeadY = hy;
              }
              // Draw head (ball)
              const ballR = this.ballRadiusPx;
              if (this.ballPrevImage && this.ballPrevBox) {
                try { ctx.putImageData(this.ballPrevImage, this.ballPrevBox.x, this.ballPrevBox.y); } catch(_) {}
              }
              // Soft glow under ball instead of dark shadow for lighter style
              const glow = ctx.createRadialGradient(hx, hy, ballR*0.2, hx, hy, ballR*1.3);
              glow.addColorStop(0, 'rgba(255,255,255,0.55)');
              glow.addColorStop(1, 'rgba(255,255,255,0)');
              ctx.save(); ctx.globalCompositeOperation = 'lighter';
              ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(hx, hy, ballR*1.3, 0, Math.PI*2); ctx.fill(); ctx.restore();
              // Ball body with highlight
              const grad = ctx.createRadialGradient(hx - ballR*0.4, hy - ballR*0.4, ballR*0.2, hx, hy, ballR);
              grad.addColorStop(0, '#eeeeee');
              grad.addColorStop(0.45, '#d9d9d9');
              grad.addColorStop(1, '#b5b5b5');
              ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(hx, hy, ballR, 0, Math.PI * 2); ctx.fill();
              // Specular highlight
              ctx.fillStyle = 'rgba(255,255,255,0.75)'; ctx.beginPath(); ctx.arc(hx - ballR*0.35, hy - ballR*0.35, ballR*0.3, 0, Math.PI*2); ctx.fill();
              // Snapshot area under ball for next frame restore
              const pad = Math.ceil(ballR * 1.4);
              const bx = Math.max(0, hx - pad);
              const by = Math.max(0, hy - pad);
              const bw = Math.min(this.canvas.width - bx, pad*2);
              const bh = Math.min(this.canvas.height - by, pad*2);
              try { this.ballPrevImage = ctx.getImageData(bx, by, bw, bh); this.ballPrevBox = { x: bx, y: by }; } catch(_) {}
            }
          } else if (this.points.length === 1) {
            const p = this.points[0]; ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
          }
        },
        exportImage() {
          // Ensure frame is up to date
          this.renderFrame();
          const link = document.createElement('a');
          link.download = 'sand-pattern-' + this.pattern + '.png';
          link.href = this.canvas.toDataURL('image/png');
          link.click();
        },
        // Pattern generators – firmware-accurate translation ---------------------------
        generatePatternPoints(id) {
          const size = this.canvas.width; const cx = size / 2; const cy = size / 2; const trayR = size * 0.48;
          const MAX_R_STEPS = 7000; const STEPS_PER_MOTOR_REV = 2048; const STEPS_PER_A_AXIS_REV = 2 * STEPS_PER_MOTOR_REV;

          // --- Math helpers mirroring firmware ---
          const fmap = (n, in_min, in_max, out_min, out_max) => (n - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
          const convertDegreesToSteps = deg => Math.round(fmap(deg, 0, 360, 0, 2 * STEPS_PER_MOTOR_REV));
          const convertStepsToRadians = steps => fmap(steps, 0, 2 * STEPS_PER_MOTOR_REV, 0, 2 * Math.PI);
          const modulus = (x, y) => x < 0 ? ((x + 1) % y) + y - 1 : x % y;

          const polarToXY = (rSteps, aSteps) => {
            const clampedR = Math.max(0, Math.min(MAX_R_STEPS, rSteps));
            const rNorm = clampedR / MAX_R_STEPS; const rPx = rNorm * trayR;
            const theta = (aSteps / STEPS_PER_A_AXIS_REV) * (Math.PI * 2);
            return { x: cx + rPx * Math.cos(theta), y: cy + rPx * Math.sin(theta) };
          };

          // --- drawLine replication (stateful iterator per line) ---
          function createLineIterator(point0, point1, resolution = 100) {
            // replicate core algorithm (cartesian interpolation & polar reconversion)
            const numPoints = Math.max(0, Math.min(100, resolution));
            let p0 = { ...point0 }; let p1 = { ...point1 };
            const points = [];
            // Vertical line detection ±0.5 deg window (convertDegreesToSteps(0.5))
            const halfDegSteps = convertDegreesToSteps(0.5);
            const comparisonA = STEPS_PER_A_AXIS_REV - Math.max(p0.angular, p1.angular);
            const comparisonB = Math.min(p0.angular, p1.angular);
            let rotated = false;
            if (comparisonA - comparisonB <= halfDegSteps && comparisonA - comparisonB >= -halfDegSteps) {
              rotated = true; p0.angular += convertDegreesToSteps(90); p1.angular += convertDegreesToSteps(90);
            }
            // Cartesian coords
            const x0 = p0.radial * Math.cos(convertStepsToRadians(p0.angular));
            const y0 = p0.radial * Math.sin(convertStepsToRadians(p0.angular));
            const x1 = p1.radial * Math.cos(convertStepsToRadians(p1.angular));
            const y1 = p1.radial * Math.sin(convertStepsToRadians(p1.angular));
            const denom = x1 - x0; const m = (y1 - y0) / denom; const b = y0 - m * x0;
            let useNumPoints = numPoints;
            if (b < 100 && b > -100) useNumPoints = 100; // origin proximity boost
            const stepover = (x1 - x0) / useNumPoints;
            for (let i = 0; i < useNumPoints; i++) {
              if (i === 0) {
                points.push({ radial: p0.radial, angular: p0.angular });
              } else if (i === useNumPoints - 1) {
                points.push({ radial: p1.radial, angular: p1.angular });
              } else {
                const xtemp = x0 + (i) * stepover; // (i) because first already added
                const ytemp = m * xtemp + b;
                let theta = Math.atan2(ytemp, xtemp); if (theta < 0) theta = 2 * Math.PI + theta;
                const radial = Math.sqrt(xtemp * xtemp + ytemp * ytemp);
                points.push({ radial: Math.round(radial), angular: Math.round(fmap(theta, 0, 2 * Math.PI, 0, 2 * STEPS_PER_MOTOR_REV)) });
              }
            }
            if (rotated) {
              const shift = convertDegreesToSteps(90);
              for (const p of points) p.angular -= shift;
            }
            let idx = 0;
            return () => {
              if (idx >= points.length) return null; return points[idx++];
            };
          }

          // Polygon generator + translate (subset of firmware)
          function nGonGenerator(numPoints, radius, rotationDeg = 0) {
            const angleStep = STEPS_PER_A_AXIS_REV / numPoints; const rotSteps = convertDegreesToSteps(rotationDeg);
            const arr = []; for (let i = 0; i < numPoints; i++) arr.push({ radial: radius, angular: i * angleStep + rotSteps }); return arr;
          }
          function translatePoints(pointArray, centerPoint) {
            if (!centerPoint.radial) return pointArray; // origin
            const cx = centerPoint.radial * Math.cos(convertStepsToRadians(centerPoint.angular));
            const cy = centerPoint.radial * Math.sin(convertStepsToRadians(centerPoint.angular));
            return pointArray.map(p => {
              const x = p.radial * Math.cos(convertStepsToRadians(p.angular)) + cx;
              const y = p.radial * Math.sin(convertStepsToRadians(p.angular)) + cy;
              let theta = Math.atan2(y, x); if (theta < 0) theta += 2 * Math.PI;
              const r = Math.sqrt(x * x + y * y);
              return { radial: Math.round(r), angular: Math.round(fmap(theta, 0, 2 * Math.PI, 0, 2 * STEPS_PER_MOTOR_REV)) };
            });
          }

          // --- Pattern function factories (mirror firmware static vars via closure) ---
          const patternFactories = {
            1: () => { // Simple Spiral
              const angleDivisions = 100; const angleStep = convertDegreesToSteps(360 / angleDivisions);
              const radialDivisions = 10 * angleDivisions; let radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
              return (current, restart) => {
                if (restart) { radialStep = Math.trunc(MAX_R_STEPS / radialDivisions); }
                let target = { angular: current.angular + angleStep, radial: current.radial + radialStep };
                if (target.radial > MAX_R_STEPS || target.radial < 0) { radialStep *= -1; target.radial += 2 * radialStep; }
                return target;
              };
            },
            2: () => { // Cardioids
              const radialStep = Math.trunc(MAX_R_STEPS / 8); let direction = 1; let firstRun = true;
              return (current, restart) => {
                if (firstRun || restart) { firstRun = false; return { angular: 0, radial: 0 }; }
                const ang = current.angular + convertDegreesToSteps(43);
                let nextRad = current.radial + direction * radialStep; if (nextRad > MAX_R_STEPS || nextRad < 0) { direction *= -1; nextRad = current.radial + direction * radialStep; }
                return { angular: ang, radial: nextRad };
              };
            },
            3: () => { // Wavy Spiral
              const angleDivisions = 100; const angleStep = convertDegreesToSteps(360 / angleDivisions);
              const radialDivisions = 10 * angleDivisions; let radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
              const amplitude = 200; const period = 8;
              return (current, restart) => {
                if (restart) radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
                let baseRad = current.radial + radialStep; let ang = current.angular + angleStep;
                if (baseRad > MAX_R_STEPS || baseRad < 0) { radialStep *= -1; baseRad += 2 * radialStep; }
                const wave = amplitude * Math.sin(period * convertStepsToRadians(ang));
                return { angular: ang, radial: Math.round(baseRad + wave) };
              };
            },
            4: () => { // Rotating Squares
              const segments = 20; const angleShift = convertDegreesToSteps(10);
              let p1, p2, p3, p4; let step = 0; let firstRun = true; let lineIter = null;
              const makeLine = (a, b) => (lineIter = createLineIterator(a, b, segments));
              return (current, restart) => {
                if (firstRun || restart) {
                  p1 = { angular: 0, radial: 7000 }; p2 = { angular: convertDegreesToSteps(90), radial: 7000 };
                  p3 = { angular: convertDegreesToSteps(180), radial: 7000 }; p4 = { angular: convertDegreesToSteps(270), radial: 7000 };
                  step = 0; firstRun = false; lineIter = createLineIterator(p1, p2, segments);
                }
                let point = lineIter && lineIter();
                if (!point) { // finished edge
                  step++;
                  switch (step) {
                    case 1: makeLine(p2, p3); break;
                    case 2: makeLine(p3, p4); break;
                    case 3: makeLine(p4, p1); break;
                    default:
                      // rotate and restart
                      step = 0; p1.angular += angleShift; p2.angular += angleShift; p3.angular += angleShift; p4.angular += angleShift; makeLine(p1, p2); break;
                  }
                  point = lineIter();
                }
                return point;
              };
            },
            5: () => { // Pentagon Spiral
              const vertices = 5; let vertexList = []; let start = 0, end = 1; let firstRun = true; let radialStepover = 500; let lineIter = null;
              const rebuildLine = () => { lineIter = createLineIterator(vertexList[start], vertexList[end], 100); };
              return (current, restart) => {
                if (firstRun || restart) { vertexList = nGonGenerator(vertices, 1000, 0); firstRun = false; start = 0; end = 1; radialStepover = 500; rebuildLine(); }
                let point = lineIter();
                if (!point) { // edge complete
                  start = (start + 1) % vertices; end = (end + 1) % vertices;
                  if (start === 0 && end === 1) { // completed polygon, adjust radii
                    for (let i = 0; i < vertices; i++) {
                      let newR = vertexList[i].radial + radialStepover; if (newR > MAX_R_STEPS || newR < 0) { radialStepover *= -1; newR += 2 * radialStepover; }
                      vertexList[i].radial = newR;
                    }
                  }
                  rebuildLine(); point = lineIter();
                }
                return point;
              };
            },
            6: () => { // Hexagon Vortex
              const vertices = 6; let step = 0; let segments = 100; let firstRun = true; let radialStepover = 350; let radius = 1000; const angleShift = convertDegreesToSteps(5);
              let points = []; let lineIter = null; let idxEdge = 0;
              const rebuildHex = () => { points = nGonGenerator(vertices, radius, 0); };
              const startEdge = () => { const a = points[idxEdge]; const b = points[(idxEdge + 1) % vertices]; lineIter = createLineIterator(a, b, segments); };
              return (current, restart) => {
                if (firstRun || restart) { firstRun = false; step = 0; radius = 1000; radialStepover = 350; idxEdge = 0; rebuildHex(); startEdge(); }
                let pt = lineIter();
                if (!pt) { // move to next edge or rotate/resize
                  idxEdge++;
                  if (idxEdge >= vertices) { // hex complete
                    idxEdge = 0; // rotate
                    for (const p of points) p.angular += angleShift;
                    if ((radius + radialStepover >= MAX_R_STEPS + 2000) || (radius + radialStepover <= 0)) radialStepover *= -1;
                    radius += radialStepover; for (const p of points) p.radial = radius;
                  }
                  startEdge(); pt = lineIter();
                }
                return pt;
              };
            },
            7: () => { // Pentagon Rainbow
              const vertices = 5; const shiftDeg = 2; const baseRadius = 3000; const translateRadius = 4000; let firstRun = true; let shiftCounter = 1; let pointList = []; let start = 0, end = 1; let lineIter = null;
              const rebuildPent = () => {
                pointList = nGonGenerator(vertices, baseRadius, shiftCounter * shiftDeg);
                pointList = translatePoints(pointList, { radial: translateRadius, angular: shiftCounter * convertDegreesToSteps(shiftDeg) });
                start = 0; end = 1; lineIter = createLineIterator(pointList[start], pointList[end], 100);
              };
              return (current, restart) => {
                if (firstRun || restart) { firstRun = false; shiftCounter = 1; rebuildPent(); }
                let pt = lineIter();
                if (!pt) {
                  start = (start + 1) % vertices; end = (end + 1) % vertices;
                  if (start === 0 && end === 1) { shiftCounter++; rebuildPent(); pt = lineIter(); } else { lineIter = createLineIterator(pointList[start], pointList[end], 100); pt = lineIter(); }
                }
                return pt;
              };
            },
            8: () => { // Random Walk 1 (random absolute targets)
              return (current, restart) => {
                if (restart) return { angular: 0, radial: 0 };
                return { angular: Math.floor(Math.random() * STEPS_PER_A_AXIS_REV), radial: Math.floor(Math.random() * (MAX_R_STEPS + 1)) };
              };
            },
            9: () => { // Random Walk 2 (straight lines between random points)
              let makeNew = true; let randomPoint = null; let lastPoint = null; let lineIter = null;
              return (current, restart) => {
                if (restart) { makeNew = true; lastPoint = current; }
                if (makeNew) {
                  randomPoint = { radial: Math.floor(Math.random() * (MAX_R_STEPS + 1)), angular: Math.floor(Math.random() * STEPS_PER_A_AXIS_REV) };
                  lineIter = createLineIterator(lastPoint || current, randomPoint, 100); makeNew = false;
                }
                const pt = lineIter();
                if (!pt) { makeNew = true; lastPoint = randomPoint; return lastPoint; }
                return pt;
              };
            },
            10: () => { // Accidental Butterfly
              const angleDivisions = 100; const angleStep = convertDegreesToSteps(360 / angleDivisions);
              const radialDivisions = 10 * angleDivisions; let radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
              return (current, restart) => {
                if (restart) radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
                let ang = current.angular + angleStep; let rad = current.radial + radialStep;
                if (rad > MAX_R_STEPS || rad < 0) { radialStep *= -1; rad += 2 * radialStep; }
                const rOffset = 200 * Math.sin(8 * convertStepsToRadians(ang));
                const aOffset = 40 * Math.cos(3 * convertStepsToRadians(ang)); // NOTE: firmware adds this directly in steps (not degrees)
                // Firmware logic: target.radial += rOffset; target.angular += aOffset; where aOffset amplitude is 40 steps.
                return { radial: Math.round(rad + rOffset), angular: Math.round(ang + aOffset) };
              };
            }
          };

          // --- Simulation driver ---
          const factory = patternFactories[id]; if (!factory) return [];
          const stepFn = factory();
          const targetPoints = this.patternMeta[id - 1]?.pointsTarget || 2000;
          let current = { radial: 0, angular: 0 }; let restart = true; const pts = [];
          let safety = targetPoints * 4; // guardrail halt
          while (pts.length < targetPoints && safety-- > 0) {
            const target = stepFn(current, restart);
            restart = false;
            // orchestrateMotion simplified effect: final position equals target (angle wrapped)
            current = {
              radial: Math.max(0, Math.min(MAX_R_STEPS, target.radial)),
              angular: modulus(target.angular, STEPS_PER_A_AXIS_REV)
            };
            const xy = polarToXY(current.radial, current.angular);
            pts.push(xy);
          }
          return pts;
        }
      }
    }

    // Simple debounce helper
    function debounce(fn, wait) {
      let t; return function (...args) { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), wait); };
    }
  </script>
</body>

</html>