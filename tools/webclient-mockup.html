<!DOCTYPE html>
<html lang="en" class="h-full">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sand Garden Controller</title>
  <!-- TailwindCSS v4 CDN (placeholder; update if hash changes) -->
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  <script>
    // Tailwind config (runtime) – custom colors & fonts
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            sg: {
              bg: '#0d0d0f',
              panel: '#16171b',
              accent: '#ff7a00', // orange screw color
              accentAlt: '#ff9d3d',
              ring: '#ffffff'
            }
          },
          boxShadow: {
            'inner-glow': 'inset 0 0 8px rgba(255,122,0,0.4)',
            'sand': '0 0 0 2px #ffffff10, 0 0 12px 4px #ffffff08 inset'
          }
        }
      }
    }
  </script>
  <!-- Alpine.js for lightweight reactivity -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    /* Scrollbar theming */
    ::-webkit-scrollbar {
      width: 10px;
    }

    ::-webkit-scrollbar-track {
      background: #111;
    }

    ::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 6px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #444;
    }

    /* Screw indicators */
    .sg-screw {
      width: 18px;
      height: 18px;
      border: 2px solid #ff7a00;
      border-radius: 50%;
      position: absolute;
      box-shadow: 0 0 6px 2px rgba(255, 122, 0, 0.35), inset 0 0 4px rgba(255, 122, 0, 0.4);
    }

    .sg-screw::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 2px;
      background: #ff7a00;
      transform: translate(-50%, -50%);
    }

    /* Circle (sand tray) */
    .sand-tray {
      aspect-ratio: 1/1;
      border: 4px solid #fff;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 50%, #ffffff 0%, #d9d9d9 55%, #cfcfcf 70%, #bfbfbf 90%);
      position: relative;
    }

    .tray-overlay {
      position: absolute;
      inset: 0;
      mix-blend-mode: multiply;
      pointer-events: none;
    }

    .pattern-canvas {
      width: 100%;
      height: 100%;
      border-radius: 50%;
    }
  </style>
</head>

<body class="h-full bg-sg-bg text-gray-100 font-sans antialiased">
  <div class="min-h-full flex flex-col" x-data="sandGardenApp()" x-init="init()">
    <!-- Header -->
    <header class="px-6 py-4 border-b border-gray-700/40 flex items-center gap-6 bg-sg-panel/70 backdrop-blur-md">
      <div class="flex items-center gap-3">
        <div class="relative w-10 h-10">
          <div
            class="absolute inset-0 rounded-full bg-gradient-to-br from-sg-accent to-sg-accentAlt blur-sm opacity-70">
          </div>
          <div
            class="relative inset-0 w-full h-full rounded-full flex items-center justify-center bg-sg-panel text-sg-accent font-bold tracking-wider">
            SG</div>
        </div>
        <h1 class="text-xl font-semibold tracking-wide">Sand Garden<span
            class="text-sg-accent text-base font-medium">Controller</span></h1>
      </div>
      <div class="flex-1"></div>
      <div class="flex items-center gap-4">
        <button @click="toggleRun()"
          :class="running ? 'bg-red-600 hover:bg-red-500' : 'bg-sg-accent hover:bg-sg-accent/80'"
          class="px-4 py-2 rounded-md font-medium transition shadow-inner-glow focus:outline-none focus:ring-2 focus:ring-sg-accent/60">
          <span x-text="running ? 'Stop' : 'Run'"></span> </button>
        <button @click="connect()"
          class="px-4 py-2 rounded-md bg-gray-700 hover:bg-gray-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-sg-accent/60"
          :disabled="connecting || connected" :class="(connecting||connected) ? 'opacity-60 cursor-not-allowed' : ''">
          <span x-show="!connected && !connecting">Connect</span>
          <span x-show="connecting">Connecting...</span>
          <span x-show="connected">Connected</span>
        </button>
        <button x-show="!connected && device && !connecting" @click="reconnect()"
          class="px-4 py-2 rounded-md bg-gray-700 hover:bg-gray-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-sg-accent/60">Reconnect</button>
      </div>
    </header>

    <!-- Main Layout -->
    <main class="flex-1 grid xl:grid-cols-3 gap-6 p-6">
      <!-- Left Column: Status & Config -->
      <section class="space-y-6">
        <!-- Device Status -->
        <div class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow relative">
          <h2 class="text-lg font-semibold mb-3 flex items-center gap-2">Device Status
            <span class="inline-flex items-center" :class="connected ? 'text-green-400' : 'text-gray-400'">
              <span class="w-2.5 h-2.5 rounded-full mr-1"
                :class="connected ? 'bg-green-400 animate-pulse' : 'bg-gray-500' "></span>
              <span x-text="connected ? 'Online' : 'Offline'"></span>
            </span>
          </h2>
          <dl class="text-sm grid grid-cols-2 gap-x-6 gap-y-2">
            <div>
              <dt class="text-gray-400">Speed Multiplier</dt>
              <dd class="font-mono" x-text="speedMultiplier.toFixed(2)"></dd>
            </div>
            <div>
              <dt class="text-gray-400">Mode</dt>
              <dd class="font-mono" x-text="autoMode ? 'Automatic' : 'Manual'"></dd>
            </div>
            <div>
              <dt class="text-gray-400">Pattern</dt>
              <dd class="font-mono" x-text="pattern + ' - ' + patternMeta[pattern-1].name"></dd>
            </div>
            <div>
              <dt class="text-gray-400">Running</dt>
              <dd class="font-mono" x-text="running ? 'Yes' : 'No'"></dd>
            </div>
          </dl>
          <div class="mt-4 text-xs text-gray-400" x-text="statusMessage"></div>
        </div>

        <!-- Configuration -->
        <form @submit.prevent
          class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow space-y-5">
          <h2 class="text-lg font-semibold mb-1">Configuration</h2>
          <div>
            <label for="speedMultiplier" class="block text-sm font-medium mb-1">Speed Multiplier <span
                class="text-gray-500">(0.1 - 3.0)</span></label>
            <div class="flex items-center gap-3">
              <input id="speedMultiplier" type="range" min="0.1" max="3" step="0.1" x-model.number="speedMultiplier"
                @input="debouncedSendSpeed()" class="w-full accent-sg-accent" />
              <input type="number" step="0.1" min="0.1" max="3" x-model.number="speedMultiplier" @change="sendSpeed()"
                class="w-20 bg-gray-800 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-sg-accent/50" />
            </div>
          </div>
          <div class="flex items-center gap-4">
            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
              <input type="checkbox" x-model="autoMode" @change="sendMode()"
                class="rounded bg-gray-800 border-gray-600 text-sg-accent focus:ring-sg-accent/60" />
              <span class="text-sm">Automatic Mode</span>
            </label>
            <label class="inline-flex items-center gap-2 cursor-pointer select-none">
              <input type="checkbox" x-model="showTrails"
                class="rounded bg-gray-800 border-gray-600 text-sg-accent focus:ring-sg-accent/60" />
              <span class="text-sm">Show Trails</span>
            </label>
          </div>
          <div class="flex gap-3">
            <button type="button" @click="centerView()"
              class="px-3 py-2 rounded-md bg-gray-700 hover:bg-gray-600 text-sm font-medium">Center View</button>
            <button type="button" @click="clearPattern()"
              class="px-3 py-2 rounded-md bg-gray-700 hover:bg-gray-600 text-sm font-medium">Clear Pattern</button>
          </div>
        </form>

        <!-- Logs -->
        <div
          class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow flex flex-col h-64">
          <h2 class="text-lg font-semibold mb-2">Event Log</h2>
          <div class="flex-1 overflow-auto text-xs space-y-1 leading-relaxed font-mono" x-ref="log">
            <template x-for="(line, idx) in logs" :key="idx">
              <div class="text-gray-400" x-text="line"></div>
            </template>
          </div>
          <div class="pt-2 flex justify-end">
            <button @click="logs=[]" class="text-xs text-sg-accent hover:underline">Clear</button>
          </div>
        </div>
      </section>

      <!-- Middle: Pattern Selection -->
      <section class="space-y-6">
        <div class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow">
          <h2 class="text-lg font-semibold mb-4">Patterns</h2>
          <ul class="grid sm:grid-cols-2 gap-3">
            <template x-for="p in patternMeta" :key="p.id">
              <li>
                <button @click="selectPattern(p.id)"
                  :class="pattern === p.id ? 'ring-2 ring-sg-accent/70 bg-sg-accent/10' : 'hover:bg-gray-700/50'"
                  class="w-full text-left px-3 py-2 rounded-lg bg-gray-800/40 border border-gray-700/60 transition duration-150 focus:outline-none focus:ring-2 focus:ring-sg-accent/50">
                  <div class="flex justify-between items-center">
                    <span class="font-medium" x-text="p.id + '. ' + p.name"></span>
                    <span class="text-xs text-gray-400" x-text="p.short"></span>
                  </div>
                </button>
              </li>
            </template>
          </ul>
        </div>

        <div class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow">
          <h2 class="text-lg font-semibold mb-3">Pattern Details</h2>
          <div class="text-sm text-gray-300" x-text="patternMeta[pattern-1].description"></div>
        </div>

        <!-- DSL Script Editor (custom pattern tooling) -->
        <div class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow space-y-3">
          <div class="flex items-center gap-3">
            <h2 class="text-lg font-semibold">DSL Script</h2>
            <span class="text-xs px-2 py-0.5 rounded bg-gray-700/60" x-text="compiledScript ? 'Compiled' : 'Not Compiled'"></span>
          </div>
          <p class="text-xs text-gray-400 leading-relaxed">Assign <code class='font-mono text-sg-accent'>next_radius</code>, <code class='font-mono text-sg-accent'>next_angle</code> or relative <code class='font-mono text-sg-accent'>delta_radius</code>, <code class='font-mono text-sg-accent'>delta_angle</code>. Inputs: <code class='font-mono'>radius</code> (cm 0–15), <code class='font-mono'>angle</code> (deg wrap 0–360), <code class='font-mono'>start</code> (1 first step), <code class='font-mono'>rev</code> (angle/360). Functions: <code class='font-mono'>sin cos abs clamp(x,a,b) sign(x)</code>. Use <code class='font-mono'>sign(cos(rev*180))</code> or similar to build arithmetic mirror / ping‑pong direction (<code class='font-mono'>dir</code>) and multiply your angular increment. All math is cm/deg; hardware conversion is automatic. Comments start with <code class='font-mono'>#</code>.</p>
          <div class="flex flex-wrap gap-2 text-[11px]">
            <template x-for="ex in exampleScripts" :key="ex.name">
              <button @click="loadExample(ex)" class="px-2 py-1 rounded bg-gray-700 hover:bg-gray-600 font-mono" x-text="ex.name"></button>
            </template>
            <label class="inline-flex items-center gap-1 ml-auto cursor-pointer select-none text-xs">
              <input type="checkbox" x-model="autoRecompile" class="rounded bg-gray-800 border-gray-600 text-sg-accent focus:ring-sg-accent/60" />
              <span>Auto-compile</span>
            </label>
            <label class="inline-flex items-center gap-1 cursor-pointer select-none text-xs">
              <input type="checkbox" x-model="autoSimulate" class="rounded bg-gray-800 border-gray-600 text-sg-accent focus:ring-sg-accent/60" />
              <span>Auto-sim</span>
            </label>
          </div>
          <div class="flex gap-3 items-start">
            <textarea x-model="scriptSource" class="w-full h-48 font-mono text-sm bg-gray-900/70 border border-gray-600 rounded p-2 focus:outline-none focus:ring-2 focus:ring-sg-accent/50 resize-y" spellcheck="false"></textarea>
            <div class="flex flex-col gap-2 w-40">
              <button @click="compileScript()" class="px-3 py-2 rounded bg-sg-accent hover:bg-sg-accent/80 text-sm font-medium">Compile</button>
              <button @click="useScriptPattern()" :disabled="!compiledScript" :class="!compiledScript ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-600'" class="px-3 py-2 rounded bg-gray-700 text-sm font-medium">Use Script</button>
              <button @click="simulateScript()" :disabled="!compiledScript" :class="!compiledScript ? 'opacity-40 cursor-not-allowed' : 'hover:bg-gray-600'" class="px-3 py-2 rounded bg-gray-700 text-sm font-medium">Simulate</button>
            </div>
          </div>
          <div class="flex items-center gap-4 text-xs flex-wrap">
            <span class="text-gray-500">Used outputs: <span class="text-sg-accent" x-text="compiledScript ? compiledScript.used.filter(u=>['next_radius','next_angle','delta_radius','delta_angle'].includes(u)).join(', ') : '-' "></span></span>
          </div>
          <template x-if="compileErrors.length">
            <div class="text-xs font-mono bg-red-900/40 border border-red-600/60 rounded p-2 space-y-1 overflow-auto max-h-40">
              <template x-for="(e,i) in compileErrors" :key="i">
                <div><span class="text-red-400" x-text="e.pos != null ? ('['+e.pos+']') : ''"></span> <span x-text="e.message"></span></div>
              </template>
            </div>
          </template>
          <template x-if="!compileErrors.length && compiledScript">
            <div class="text-xs font-mono bg-emerald-900/30 border border-emerald-600/50 rounded p-2">
              OK
            </div>
          </template>
          <!-- Bytecode listing removed -->
        </div>

      </section>

      <!-- Right: Visualizer -->
      <section class="space-y-6">
        <div class="bg-sg-panel/60 backdrop-blur rounded-xl p-5 border border-gray-700/50 shadow-inner-glow relative">
          <h2 class="text-lg font-semibold mb-3">Visualizer</h2>
          <div class="relative">
            <!-- Screws around tray -->
            <div class="sg-screw" style="top:-12px; left:50%; transform:translateX(-50%);"></div>
            <div class="sg-screw" style="bottom:-12px; left:50%; transform:translateX(-50%);"></div>
            <div class="sg-screw" style="left:-12px; top:50%; transform:translateY(-50%);"></div>
            <div class="sg-screw" style="right:-12px; top:50%; transform:translateY(-50%);"></div>
            <div class="sand-tray shadow-sand" x-ref="tray">
              <canvas x-ref="canvas" class="pattern-canvas"></canvas>
              <div class="tray-overlay rounded-full pointer-events-none"></div>
            </div>
          </div>
          <div class="mt-4 flex flex-wrap gap-3 text-xs">
            <button @click="regeneratePattern()"
              class="px-3 py-1.5 rounded bg-gray-700 hover:bg-gray-600">Regenerate</button>
            <button @click="toggleSimulation()" class="px-3 py-1.5 rounded bg-gray-700 hover:bg-gray-600"
              x-text="simulationRunning ? 'Pause' : 'Play'"></button>
            <button @click="exportImage()" class="px-3 py-1.5 rounded bg-gray-700 hover:bg-gray-600">Export</button>
            <label class="inline-flex items-center gap-1 cursor-pointer select-none ml-auto">
              <input type="checkbox" x-model="showTrails" @change="onShowTrailsChange()"
                class="rounded bg-gray-800 border-gray-600 text-sg-accent focus:ring-sg-accent/60" />
              <span>Show Trails</span>
            </label>
          </div>
        </div>
      </section>
    </main>

    <footer class="px-6 py-3 text-xs text-gray-500 flex justify-between border-t border-gray-800 bg-sg-panel/60">
      <div>Sand Garden UI – Firmware integration TBD.</div>
      <div>Colors: Device Black + Orange Screws + White Sand</div>
    </footer>
  </div>

  <script>
    function sandGardenApp() {
      return {
        // State
        connected: false,
        connecting: false,
        running: false,
        autoMode: true,
        speedMultiplier: 1.0,
        pattern: 1,
        showTrails: true,
        statusMessage: 'Idle',
        logs: [],
        device: null, server: null,
        chars: { speed: null, pattern: null, status: null, mode: null, run: null, telemetry: null },
        // Telemetry state
        joy: { a: 0, r: 0, mag: 0 }, lastState: { pat: null, auto: null, run: null, brt: null }, heartbeatCount: 0,
        patternMeta: [
          // Added pointsTarget to guide simulation length (approx, can tweak)
          { id: 1, name: 'Simple Spiral', short: 'spiral', description: 'Outward then inward spiral path (firmware logic).', pointsTarget: 4500 },
          { id: 2, name: 'Cardioids', short: 'cardioid', description: 'Petaled cardioid style looping figure.', pointsTarget: 1200 },
          { id: 3, name: 'Wavy Spiral', short: 'wavy', description: 'Spiral with sinusoidal radial modulation.', pointsTarget: 4600 },
          { id: 4, name: 'Rotating Squares', short: 'squares', description: 'Sequence of rotating square outlines.', pointsTarget: 2300 },
          { id: 5, name: 'Pentagon Spiral', short: 'penta sp', description: 'Pentagon-based growing & shrinking spiral.', pointsTarget: 3200 },
          { id: 6, name: 'Hexagon Vortex', short: 'hexa', description: 'Rotating, pulsing hexagon vortex.', pointsTarget: 3000 },
          { id: 7, name: 'Pentagon Rainbow', short: 'penta rb', description: 'Off-center rotating/translated pentagon.', pointsTarget: 2500 },
          { id: 8, name: 'Random Walk 1', short: 'rw arc', description: 'Random absolute targets (shortest angular path).', pointsTarget: 1800 },
          { id: 9, name: 'Random Walk 2', short: 'rw line', description: 'Random straight-line interpolation between points.', pointsTarget: 1800 },
          { id: 10, name: 'Accidental Butterfly', short: 'butterfly', description: 'Sinusoidally modulated spiral (butterfly).', pointsTarget: 4600 },
          { id: 11, name: 'Custom Script (DSL)', short: 'script', description: 'Your DSL compiled script.', pointsTarget: 2000 }
        ],
        // DSL script state
  scriptSource: `# PingPong Petals (fine-step)\n# Smaller angular/radial increments for smooth petals\ndir = sign(cos(rev*180))\nwave = sin(angle*5)*0.45 + sin(angle*9)*0.20\nbase = clamp(radius + 0.10 + wave*0.30, 0, 15)\nnext_radius = base\nnext_angle = angle + (5.5 + sin(angle*3)*1.3) * dir`,
        compileErrors: [],
        compiledScript: null,
  // Continuous revolution tracking for DSL (rev variable)
  revPrevAngleDeg: null,
  revUnwrappedAngleDeg: 0,
    // scriptSteps removed (infinite logical simulation); max radius locked by constant below
  scriptMaxRadius: 15, // in cm (change in code only)
  // showBytecode removed
        autoRecompile: true,
        autoSimulate: true,
        exampleScripts: [
  { name:'PingPongPetals', code:`# Fine-step dir flips every revolution (mirror)\ndir = sign(cos(rev*180))\nwave = sin(angle*5)*0.45 + sin(angle*9)*0.20\nbase = clamp(radius + 0.10 + wave*0.30, 0, 15)\nnext_radius = base\nnext_angle = angle + (5.5 + sin(angle*3)*1.3) * dir` },
  { name:'MirrorSpiral', code:`# Smooth mirror spiral (out then in each revolution)\n# Continuous rev used; phase = (sin(rev*360)+1)/2 yields 0->1->0 per revolution\nphase = (sin(rev*360) + 1) * 0.5\ntarget = phase * 15\nnext_radius = clamp(radius + (target - radius)*0.30, 0, 15)\nnext_angle = angle + 5.8 + sin(angle*4)*1.0` },
  { name:'EchoBloom', code:`# Fine-step dual-frequency bloom\nphase = sin(rev*90)*10\nring = sin(angle*4 + phase)*0.40 + sin(angle*7 - phase*0.5)*0.18\nnext_radius = clamp(7.5 + ring*6.0, 0, 15)\nnext_angle = angle + 4.5 + sin(angle*6)*0.9` },
  { name:'BounceWeave', code:`# Fine-step radial bounce\nweave = abs(sin(angle*3))*0.55 + abs(sin(angle*11))*0.20\nnext_radius = clamp(6 + weave*6.0, 0, 15)\nnext_angle = angle + 5.8 + sin(angle*5)*1.3` },
  { name:'StarPing', code:`# Fine-step star points with flips\ndir = sign(cos(rev*180))\narm = abs(sin(angle*2.5))*0.75 + abs(sin(angle*5))*0.28\nnext_radius = clamp(4 + arm*7.2, 0, 15)\nnext_angle = angle + (6 + sin(angle*2.5)*1.8) * dir` },
  { name:'LaceHelix', code:`# Fine-step lace helix\nmod = sin(angle*4)*0.24 + sin(angle*9)*0.16 + sin(angle*13)*0.11\nnext_radius = clamp(radius + 0.06 + mod, 0, 15)\nnext_angle = angle + 5 + sin(angle*5)*1.5` },
  { name:'RevCascade', code:`# Fine-step growth bursts\nphase = sign(cos(rev*180))\nnext_radius = clamp(radius + 0.08 + phase*0.12 + sin(angle*6)*0.18, 0, 15)\nnext_angle = angle + 6 + sin(angle*4)*1.2` },
  { name:'StartBurst', code:`# Fine-step start flare then weave\nflare = start*4.5\nnext_radius = clamp(radius + flare + sin(angle*5)*0.25, 0, 15)\nnext_angle = angle + 6 + sin(angle*3)*1.4` },
  { name:'PetalDrift', code:`# Fine-step outward drift petals\nwave = sin(angle*6)*0.42 + sin(angle*11)*0.12\nnext_radius = clamp(radius + 0.07 + wave*0.25, 0, 15)\nnext_angle = angle + 5.5 + sin(angle*4)*1.3` },
  { name:'SelfRefWarp', code:`# Fine-step self-referential warp spiral\nnext_radius = clamp(radius + 0.14 - radius*0.008, 0, 15)\nnext_angle = angle + 5.5 + 7*sin(next_radius*10)` }
],
        mirrorMode: false, // new mirror mode toggle (UI control can set this)
        // Drawing
  canvas: null, ctx: null, traySize: 0, points: [],
  // Ball & trench visualization (direct stamping; no offscreen accumulation)
  ballRadiusPx: 6, trenchDepth: 1.0, trenchSoftness: 8,
  lastHeadX: null, lastHeadY: null, trenchStampSpacingFactor: 0.55, // spacing = ballRadiusPx * factor
  trailInitialized: false, ballPrevImage: null, ballPrevBox: null,
        // simulation timing (distance based)
        simulationRunning: false, linearSpeed: 300, lastTs: 0,
        simulationDistance: 0, totalPathLength: 0,
        segmentLengths: [], segmentEndDistances: [], segmentIndex: 0,
        segmentPolar: [], // per segment polar interpolation data {r0,r1,dr,theta0,theta1,dθ,length}
        pointsPolar: [], // derived polar coordinates for each point (r, theta)
        // path accumulation
        pathCanvas: null, pathCtx: null, lastDrawnSegmentIndex: 0,
        init() {
          this.canvas = this.$refs.canvas;
          this.ctx = this.canvas.getContext('2d');
          this.resizeCanvas();
          window.addEventListener('resize', () => this.resizeCanvas());
          this.regeneratePattern();
          this.log('UI initialized');
        },
        resizeCanvas() {
          const rect = this.$refs.tray.getBoundingClientRect();
          const size = Math.min(rect.width, rect.height);
          this.canvas.width = size; this.canvas.height = size; this.traySize = size;
          this.ensurePathBuffer();
          this.clearPath();
          this.renderFrame();
        },
        log(msg) {
          const t = new Date().toLocaleTimeString();
          this.logs.push(`[${t}] ${msg}`);
          this.$nextTick(() => {
            const el = this.$refs.log; el.scrollTop = el.scrollHeight;
          });
        },
        setStatus(s) { this.statusMessage = s; this.log(s); },
        async connect() {
          if (!navigator.bluetooth) { this.setStatus('Web Bluetooth not supported'); return; }
          if (this.connected || this.connecting) return;
          this.connecting = true; this.setStatus('Requesting Sand Garden device...');
          // UUIDs from firmware BLEConfigServer.h
          const SERVICE_UUID = '9b6c7e10-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const SPEED_UUID = '9b6c7e11-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const PATTERN_UUID = '9b6c7e12-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const STATUS_UUID = '9b6c7e13-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const MODE_UUID = '9b6c7e14-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const RUN_UUID = '9b6c7e15-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const TELEMETRY_UUID = '9b6c7e16-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          const COMMAND_UUID = '9b6c7e17-3b2c-4d8c-9d7c-5e2a6d1f8b01';
          try {
            this.device = await navigator.bluetooth.requestDevice({
              filters: [{ services: [SERVICE_UUID] }],
              optionalServices: [SERVICE_UUID]
            });
            this.device.addEventListener('gattserverdisconnected', () => { this.onDisconnect(); });
            this.setStatus('Connecting GATT...');
            this.server = await this.device.gatt.connect();
            const service = await this.server.getPrimaryService(SERVICE_UUID);
            this.setStatus('Discovering characteristics...');
            const speedChar = await service.getCharacteristic(SPEED_UUID);
            const patternChar = await service.getCharacteristic(PATTERN_UUID);
            const statusChar = await service.getCharacteristic(STATUS_UUID);
            // Mode/run are optional until firmware updated; wrap in try
            let modeChar = null, runChar = null, telemetryChar = null;
            try { modeChar = await service.getCharacteristic(MODE_UUID); } catch (_) { }
            try { runChar = await service.getCharacteristic(RUN_UUID); } catch (_) { }
            try { telemetryChar = await service.getCharacteristic(TELEMETRY_UUID); } catch (_) { this.log('Telemetry characteristic not found (firmware older?)'); }
            this.chars = { speed: speedChar, pattern: patternChar, status: statusChar, mode: modeChar, run: runChar, telemetry: telemetryChar };
            // Initial reads
            await this.readInitialValues();
            // Notifications
            await Promise.all([
              speedChar.startNotifications().then(() => {
                speedChar.addEventListener('characteristicvaluechanged', e => { this.handleSpeedNotify(e); });
              }),
              patternChar.startNotifications().then(() => {
                patternChar.addEventListener('characteristicvaluechanged', e => { this.handlePatternNotify(e); });
              }),
              statusChar.startNotifications().then(() => {
                statusChar.addEventListener('characteristicvaluechanged', e => { this.handleStatusNotify(e); });
              }),
              modeChar && modeChar.startNotifications().then(() => {
                modeChar.addEventListener('characteristicvaluechanged', e => { this.handleModeNotify(e); });
              }).catch(() => { }),
              runChar && runChar.startNotifications().then(() => {
                runChar.addEventListener('characteristicvaluechanged', e => { this.handleRunNotify(e); });
              }).catch(() => { }),
              telemetryChar && telemetryChar.startNotifications().then(() => {
                telemetryChar.addEventListener('characteristicvaluechanged', e => { this.handleTelemetryNotify(e); });
              }).catch(() => { })
            ]);
            this.connected = true; this.setStatus('Connected');
            this.log('BLE ready.');
          } catch (err) {
            this.setStatus('Connection failed: ' + err.message);
            this.log('Error: ' + err.stack);
          } finally { this.connecting = false; }
        },
        async readInitialValues() {
          // Firmware sends ASCII; parse accordingly
          try {
            if (this.chars.speed) {
              const v = await this.chars.speed.readValue();
              const txt = this.textFromDV(v); const num = parseFloat(txt); if (!isNaN(num)) this.speedMultiplier = num;
            }
            if (this.chars.pattern) {
              const v = await this.chars.pattern.readValue();
              const txt = this.textFromDV(v); const num = parseInt(txt); if (!isNaN(num)) this.pattern = num;
            }
            if (this.chars.status) {
              const v = await this.chars.status.readValue();
              this.statusMessage = this.textFromDV(v);
            }
            if (this.chars.mode) {
              const v = await this.chars.mode.readValue();
              const txt = this.textFromDV(v); const num = parseInt(txt); this.autoMode = (num === 1);
            }
            if (this.chars.run) {
              const v = await this.chars.run.readValue();
              const txt = this.textFromDV(v); const num = parseInt(txt); this.running = (num === 1);
            }
          } catch (e) { this.log('Read init failed: ' + e.message); }
        },
        // Notification handlers
        handleSpeedNotify(e) { const txt = this.textFromDV(e.target.value); const num = parseFloat(txt); if (!isNaN(num)) { this.speedMultiplier = num; this.log('Speed->' + num.toFixed(3)); } },
        handlePatternNotify(e) { const txt = this.textFromDV(e.target.value); const num = parseInt(txt); if (!isNaN(num)) { this.pattern = num; this.regeneratePattern(); this.log('Pattern->' + num); } },
        handleStatusNotify(e) { const txt = this.textFromDV(e.target.value); this.setStatus(txt); },
        handleModeNotify(e) { const txt = this.textFromDV(e.target.value); const num = parseInt(txt); this.autoMode = (num === 1); this.log('Mode->' + (this.autoMode ? 'Auto' : 'Manual')); },
        handleRunNotify(e) { const txt = this.textFromDV(e.target.value); const num = parseInt(txt); this.running = (num === 1); this.log('Run->' + (this.running ? 'Running' : 'Stopped')); },
        handleTelemetryNotify(e) {
          const txt = this.textFromDV(e.target.value);
          // Expect lines like: JOY a=12 r=-3 mag=12 | STATE pat=1 auto=1 run=1 brt=40 | HB
          if (txt.startsWith('JOY ')) {
            const parts = Object.fromEntries(txt.substring(4).split(/\s+/).map(kv => kv.split('=')));
            const a = parseInt(parts.a) || 0; const r = parseInt(parts.r) || 0; const mag = parseInt(parts.mag) || Math.max(Math.abs(a), Math.abs(r));
            this.joy = { a, r, mag };
            this.log(`JOY a=${a} r=${r} mag=${mag}`);
          } else if (txt.startsWith('STATE ')) {
            const parts = Object.fromEntries(txt.substring(6).split(/\s+/).map(kv => kv.split('=')));
            const pat = parseInt(parts.pat); const auto = parts.auto === '1'; const run = parts.run === '1'; const brt = parseInt(parts.brt);
            this.lastState = { pat, auto, run, brt };
            // Optionally sync if drifted
            if (!isNaN(pat) && pat !== this.pattern) this.pattern = pat;
            if (typeof auto === 'boolean' && auto !== this.autoMode) this.autoMode = auto;
            if (typeof run === 'boolean' && run !== this.running) this.running = run;
          } else if (txt === 'HB') {
            this.heartbeatCount++; this.log('HB ' + this.heartbeatCount);
          } else {
            this.log('TL ' + txt);
          }
        },
        textFromDV(dv) { let str = ''; for (let i = 0; i < dv.byteLength; i++) { const c = dv.getUint8(i); if (c === 0) break; str += String.fromCharCode(c); } return str.trim(); },
        toggleRun() { this.running = !this.running; this.sendRun(); },
        debouncedSendSpeed: debounce(function () { this.sendSpeed(); }, 400),
        async sendSpeed() {
          this.setStatus('Speed multiplier -> ' + this.speedMultiplier.toFixed(2));
          if (this.chars.speed) {
            try { const txt = new TextEncoder().encode(this.speedMultiplier.toFixed(3)); await this.chars.speed.writeValue(txt); }
            catch (e) { this.log('Speed write err: ' + e.message); }
          }
        },
        async sendMode() {
          this.setStatus('Mode -> ' + (this.autoMode ? 'Automatic' : 'Manual'));
          if (this.chars.mode) {
            try { const txt = new TextEncoder().encode(this.autoMode ? '1' : '0'); await this.chars.mode.writeValue(txt); }
            catch (e) { this.log('Mode write err: ' + e.message); }
          }
        },
        async sendRun() {
          this.setStatus(this.running ? 'Pattern running' : 'Pattern stopped');
          if (this.chars.run) {
            try { const txt = new TextEncoder().encode(this.running ? '1' : '0'); await this.chars.run.writeValue(txt); }
            catch (e) { this.log('Run write err: ' + e.message); }
          }
        },
        // Removed runLedSelfTest / sendCommand / direct LED color helpers (unsupported)
        async disconnectDevice() {
          if (this.device && this.device.gatt && this.device.gatt.connected) {
            try { this.device.gatt.disconnect(); this.setStatus('Disconnected'); } catch (e) { this.log('Disconnect err: ' + e.message); }
          }
          this.connected = false;
        },
        async reconnect() { if (!this.device) { return this.connect(); } if (this.connected || this.connecting) return; try { this.connecting = true; this.setStatus('Reconnecting...'); await this.device.gatt.connect(); this.connecting = false; await this.connect(); } catch (e) { this.connecting = false; this.setStatus('Reconnect failed: ' + e.message); } },
        async selectPattern(id) {
          this.pattern = id; this.setStatus('Selected pattern ' + id); this.regeneratePattern();
          if (this.chars.pattern) {
            try { const txt = new TextEncoder().encode(String(id)); await this.chars.pattern.writeValue(txt); }
            catch (e) { this.log('Pattern write err: ' + e.message); }
          }
        },
        regeneratePattern() {
         this.points = this.generatePatternPoints(this.pattern);
          this.computePathMetrics();
          this.simulationDistance = 0; this.segmentIndex = 0; this.lastDrawnSegmentIndex = 0;
          this.resetTrail();
          this.drawBackground();
          this.renderFrame();
        },
        clearPattern() { this.points = []; this.resetTrail(); this.drawBackground(); this.renderFrame(); },
        resetTrail() { this.lastHeadX = null; this.lastHeadY = null; this.trailInitialized = false; this.ballPrevImage = null; this.ballPrevBox = null; },
        centerView() { this.renderFrame(); },
        toggleSimulation() { this.simulationRunning = !this.simulationRunning; if (this.simulationRunning) { this.lastTs = 0; requestAnimationFrame(this.stepSimulation.bind(this)); } },
        stepSimulation(ts) {
          if (!this.simulationRunning) return;
          if (!this.lastTs) this.lastTs = ts; const dt = (ts - this.lastTs) / 1000; this.lastTs = ts;
          this.simulationDistance += this.linearSpeed * dt;
          if (this.simulationDistance >= this.totalPathLength) {
            this.simulationDistance = 0; this.segmentIndex = 0; this.lastDrawnSegmentIndex = 0; this.clearPath();
            if (this.trenchCtx) this.trenchCtx.clearRect(0,0,this.trenchCanvas.width,this.trenchCanvas.height);
            this.lastHeadX = null; this.lastHeadY = null;
          }
          this.updateSegmentIndex();
          this.updateTrail();
          this.renderFrame();
          requestAnimationFrame(this.stepSimulation.bind(this));
        },
        drawBackground() {
          if (!this.ctx) return; const ctx = this.ctx; const w = this.canvas.width; const h = this.canvas.height; ctx.clearRect(0, 0, w, h);
          const grad = ctx.createRadialGradient(w / 2, h / 2, w * 0.05, w / 2, h / 2, w * 0.5);
          grad.addColorStop(0, '#ffffff'); grad.addColorStop(1, '#cfcfcf');
          ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(w / 2, h / 2, w / 2 - 2, 0, Math.PI * 2); ctx.fill();
        },
        ensurePathBuffer() { /* offscreen path buffer removed */ },
        clearPath() { if (this.pathCtx) { this.pathCtx.clearRect(0, 0, this.pathCanvas.width, this.pathCanvas.height); this.lastDrawnSegmentIndex = 0; } },
        computePathMetrics() {
          this.segmentLengths = []; this.segmentEndDistances = []; this.segmentPolar = []; this.pointsPolar = []; this.totalPathLength = 0;
          const n = this.points.length; if (n < 2) return;
          const cx = this.canvas.width / 2; const cy = this.canvas.height / 2;
          // Build polar points (r in pixels, theta in radians)
          for (let i = 0; i < n; i++) {
            const p = this.points[i]; const dx = p.x - cx; const dy = p.y - cy; const r = Math.hypot(dx, dy); let theta = Math.atan2(dy, dx); // [-pi,pi]
            this.pointsPolar.push({ r, theta });
          }
          const tiny = 1e-9;
          function segmentLengthPolar(r0, r1, dr, dθ) {
            const absDr = Math.abs(dr); const absDθ = Math.abs(dθ);
            if (absDr < tiny && absDθ < tiny) return 0;
            if (absDr < tiny) return r0 * absDθ; // pure arc
            if (absDθ < tiny) return absDr; // pure radial
            const k = dr; const B = dθ * dθ; const sqrtB = Math.sqrt(B);
            function G(u) { return 0.5 * (u * Math.sqrt(k * k + B * u * u) + (k * k / sqrtB) * Math.asinh((sqrtB * u) / Math.abs(k))); }
            const L = (G(r1) - G(r0)) / k; return Math.abs(L);
          }
          for (let i = 0; i < n - 1; i++) {
            const p0 = this.pointsPolar[i]; const p1 = this.pointsPolar[i + 1];
            let dθ = p1.theta - p0.theta;
            // Shortest angular difference wrap to [-pi, pi]
            while (dθ > Math.PI) dθ -= 2 * Math.PI; while (dθ < -Math.PI) dθ += 2 * Math.PI;
            const dr = p1.r - p0.r;
            const len = segmentLengthPolar(p0.r, p1.r, dr, dθ);
            this.totalPathLength += len;
            this.segmentLengths.push(len);
            this.segmentEndDistances.push(this.totalPathLength);
            this.segmentPolar.push({ r0: p0.r, r1: p1.r, dr, theta0: p0.theta, theta1: p1.theta, dθ, length: len });
          }
        },
        updateSegmentIndex() {
          // advance segmentIndex until segmentEndDistances[segmentIndex] >= simulationDistance
          while (this.segmentIndex < this.segmentEndDistances.length - 1 && this.segmentEndDistances[this.segmentIndex] < this.simulationDistance) {
            this.segmentIndex++;
          }
        },
        updateTrail() {
          // Incremental stamping now handled inside renderFrame; keep index advance to prevent backlog if jumping
          if (!this.showTrails) return;
          this.lastDrawnSegmentIndex = this.segmentIndex;
        },
        onShowTrailsChange() {
          this.clearPath();
          if (this.showTrails) {
            // rebuild up to current segment
            const prev = this.simulationDistance; this.simulationDistance = 0; this.segmentIndex = 0; this.lastDrawnSegmentIndex = 0;
            // fast-forward drawing
            while (this.segmentIndex < this.segmentEndDistances.length && this.segmentEndDistances[this.segmentIndex] < prev) {
              this.segmentIndex++; this.updateTrail();
            }
            this.simulationDistance = prev; this.updateSegmentIndex(); this.updateTrail();
          }
          this.renderFrame();
        },
        renderFrame() {
          const ctx = this.ctx;
          if (!this.trailInitialized) { this.drawBackground(); this.trailInitialized = true; }
          // Draw head at current simulation index
          if (this.points.length >= 2 && this.segmentPolar.length) {
            const seg = this.segmentPolar[this.segmentIndex];
            if (seg) {
              const segStartDist = this.segmentIndex === 0 ? 0 : this.segmentEndDistances[this.segmentIndex - 1];
              const distWithin = this.simulationDistance - segStartDist;
              // Invert arc-length to get parameter fraction along polar segment
              let t;
              const tiny = 1e-9;
              if (seg.length < tiny) {
                t = 0;
              } else if (Math.abs(seg.dr) < tiny && Math.abs(seg.dθ) > tiny) { // pure arc
                t = distWithin / seg.length;
              } else if (Math.abs(seg.dθ) < tiny && Math.abs(seg.dr) > tiny) { // pure radial
                t = distWithin / seg.length;
              } else {
                // binary search invert lengthAt(t)
                function lengthAt(tt) {
                  // reuse analytic integral via r(t)
                  const r0 = seg.r0; const dr = seg.dr; const dθ = seg.dθ; const k = dr; const B = dθ * dθ; const sqrtB = Math.sqrt(B);
                  function G(u) { return 0.5 * (u * Math.sqrt(k * k + B * u * u) + (k * k / sqrtB) * Math.asinh((sqrtB * u) / Math.abs(k))); }
                  if (Math.abs(dr) < tiny) return r0 * Math.abs(dθ) * tt; // arc
                  const rT = r0 + dr * tt; const L = (G(rT) - G(r0)) / dr; return Math.abs(L);
                }
                let lo = 0, hi = 1; t = 0; const target = distWithin; for (let iter = 0; iter < 18; iter++) { const mid = (lo + hi) / 2; const Lm = lengthAt(mid); if (Lm < target) { lo = mid; } else { hi = mid; } } t = (lo + hi) / 2;
              }
              t = Math.min(1, Math.max(0, t));
              const cx = this.canvas.width / 2; const cy = this.canvas.height / 2;
              const r = seg.r0 + seg.dr * t; const theta = seg.theta0 + seg.dθ * t;
              const hx = cx + r * Math.cos(theta); const hy = cy + r * Math.sin(theta);
              // Incremental stamping directly on main canvas
              if (this.showTrails) {
                const spacing = this.ballRadiusPx * this.trenchStampSpacingFactor;
                const stampSegment = (x0, y0, x1, y1) => {
                  const dx = x1 - x0, dy = y1 - y0; const dist = Math.hypot(dx, dy);
                  if (dist === 0) return;
                  const steps = Math.max(1, Math.floor(dist / spacing));
                  for (let i = 0; i <= steps; i++) {
                    const f = i / steps; const sx = x0 + dx * f; const sy = y0 + dy * f;
                    const trench = ctx;
                    const innerR = this.ballRadiusPx * 0.2;
                    const outerR = this.ballRadiusPx + this.trenchSoftness;
                    const g = trench.createRadialGradient(sx, sy, innerR, sx, sy, outerR);
                    // Trench impression with reduced per-stamp opacity (so overlap builds depth)
                    g.addColorStop(0.0, 'rgba(255,255,255,0.55)');          // reduced center
                    g.addColorStop(0.28, 'rgba(245,245,245,0.38)');
                    g.addColorStop(0.55, 'rgba(230,230,230,0.22)');
                    g.addColorStop(0.75, 'rgba(200,200,200,0.15)');         // subtle mid-band
                    g.addColorStop(0.90, 'rgba(180,180,180,0.10)');         // darker rim hint
                    g.addColorStop(1.0, 'rgba(150,150,150,0)');                // fade out
                    trench.globalCompositeOperation = 'source-over';
                    trench.fillStyle = g;
                    trench.beginPath(); trench.arc(sx, sy, outerR, 0, Math.PI*2); trench.fill();
                  }
                };
                if (this.lastHeadX != null) {
                  stampSegment(this.lastHeadX, this.lastHeadY, hx, hy);
                } else {
                  stampSegment(hx, hy, hx, hy);
                }
                this.lastHeadX = hx; this.lastHeadY = hy;
              }
              // Draw head (ball)
              const ballR = this.ballRadiusPx;
              if (this.ballPrevImage && this.ballPrevBox) {
                try { ctx.putImageData(this.ballPrevImage, this.ballPrevBox.x, this.ballPrevBox.y); } catch(_) {}
              }
              // Soft glow under ball instead of dark shadow for lighter style
              const glow = ctx.createRadialGradient(hx, hy, ballR*0.2, hx, hy, ballR*1.3);
              glow.addColorStop(0, 'rgba(255,255,255,0.55)');
              glow.addColorStop(1, 'rgba(255,255,255,0)');
              ctx.save(); ctx.globalCompositeOperation = 'lighter';
              ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(hx, hy, ballR*1.3, 0, Math.PI*2); ctx.fill(); ctx.restore();
              // Ball body with highlight
              const grad = ctx.createRadialGradient(hx - ballR*0.4, hy - ballR*0.4, ballR*0.2, hx, hy, ballR);
              grad.addColorStop(0, '#eeeeee');
              grad.addColorStop(0.45, '#d9d9d9');
              grad.addColorStop(1, '#b5b5b5');
              ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(hx, hy, ballR, 0, Math.PI * 2); ctx.fill();
              // Specular highlight
              ctx.fillStyle = 'rgba(255,255,255,0.75)'; ctx.beginPath(); ctx.arc(hx - ballR*0.35, hy - ballR*0.35, ballR*0.3, 0, Math.PI*2); ctx.fill();
              // Snapshot area under ball for next frame restore
              const pad = Math.ceil(ballR * 1.4);
              const bx = Math.max(0, hx - pad);
              const by = Math.max(0, hy - pad);
              const bw = Math.min(this.canvas.width - bx, pad*2);
              const bh = Math.min(this.canvas.height - by, pad*2);
              try { this.ballPrevImage = ctx.getImageData(bx, by, bw, bh); this.ballPrevBox = { x: bx, y: by }; } catch(_) {}
            }
          } else if (this.points.length === 1) {
            const p = this.points[0]; ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
          }
        },
        exportImage() {
          // Ensure frame is up to date
          this.renderFrame();
          const link = document.createElement('a');
          link.download = 'sand-pattern-' + this.pattern + '.png';
          link.href = this.canvas.toDataURL('image/png');
          link.click();
        },
        // Pattern generators – firmware-accurate translation ---------------------------
        generatePatternPoints(id) {
          const size = this.canvas.width; const cx = size / 2; const cy = size / 2; const trayR = size * 0.48;
          const MAX_R_STEPS = 7000; const STEPS_PER_MOTOR_REV = 2048; const STEPS_PER_A_AXIS_REV = 2 * STEPS_PER_MOTOR_REV;

          // --- Math helpers mirroring firmware ---
          const fmap = (n, in_min, in_max, out_min, out_max) => (n - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
          const convertDegreesToSteps = deg => Math.round(fmap(deg, 0, 360, 0, 2 * STEPS_PER_MOTOR_REV));
          const convertStepsToRadians = steps => fmap(steps, 0, 2 * STEPS_PER_MOTOR_REV, 0, 2 * Math.PI);
          const modulus = (x, y) => x < 0 ? ((x + 1) % y) + y - 1 : x % y;

          const polarToXY = (rSteps, aSteps) => {
            const clampedR = Math.max(0, Math.min(MAX_R_STEPS, rSteps));
            const rNorm = clampedR / MAX_R_STEPS; const rPx = rNorm * trayR;
            const theta = (aSteps / STEPS_PER_A_AXIS_REV) * (Math.PI * 2);
            return { x: cx + rPx * Math.cos(theta), y: cy + rPx * Math.sin(theta) };
          };

          // --- drawLine replication (stateful iterator per line) ---
          function createLineIterator(point0, point1, resolution = 100) {
            // replicate core algorithm (cartesian interpolation & polar reconversion)
            const numPoints = Math.max(0, Math.min(100, resolution));
            let p0 = { ...point0 }; let p1 = { ...point1 };
            const points = [];
            // Vertical line detection ±0.5 deg window (convertDegreesToSteps(0.5))
            const halfDegSteps = convertDegreesToSteps(0.5);
            const comparisonA = STEPS_PER_A_AXIS_REV - Math.max(p0.angular, p1.angular);
            const comparisonB = Math.min(p0.angular, p1.angular);
            let rotated = false;
            if (comparisonA - comparisonB <= halfDegSteps && comparisonA - comparisonB >= -halfDegSteps) {
              rotated = true; p0.angular += convertDegreesToSteps(90); p1.angular += convertDegreesToSteps(90);
            }
            // Cartesian coords
            const x0 = p0.radial * Math.cos(convertStepsToRadians(p0.angular));
            const y0 = p0.radial * Math.sin(convertStepsToRadians(p0.angular));
            const x1 = p1.radial * Math.cos(convertStepsToRadians(p1.angular));
            const y1 = p1.radial * Math.sin(convertStepsToRadians(p1.angular));
            const denom = x1 - x0; const m = (y1 - y0) / denom; const b = y0 - m * x0;
            let useNumPoints = numPoints;
            if (b < 100 && b > -100) useNumPoints = 100; // origin proximity boost
            const stepover = (x1 - x0) / useNumPoints;
            for (let i = 0; i < useNumPoints; i++) {
              if (i === 0) {
                points.push({ radial: p0.radial, angular: p0.angular });
              } else if (i === useNumPoints - 1) {
                points.push({ radial: p1.radial, angular: p1.angular });
              } else {
                const xtemp = x0 + (i) * stepover; // (i) because first already added
                const ytemp = m * xtemp + b;
                let theta = Math.atan2(ytemp, xtemp); if (theta < 0) theta = 2 * Math.PI + theta;
                const radial = Math.sqrt(xtemp * xtemp + ytemp * ytemp);
                points.push({ radial: Math.round(radial), angular: Math.round(fmap(theta, 0, 2 * Math.PI, 0, 2 * STEPS_PER_MOTOR_REV)) });
              }
            }
            if (rotated) {
              const shift = convertDegreesToSteps(90);
              for (const p of points) p.angular -= shift;
            }
            let idx = 0;
            return () => {
              if (idx >= points.length) return null; return points[idx++];
            };
          }

          // Polygon generator + translate (subset of firmware)
          function nGonGenerator(numPoints, radius, rotationDeg = 0) {
            const angleStep = STEPS_PER_A_AXIS_REV / numPoints; const rotSteps = convertDegreesToSteps(rotationDeg);
            const arr = []; for (let i = 0; i < numPoints; i++) arr.push({ radial: radius, angular: i * angleStep + rotSteps }); return arr;
          }
          function translatePoints(pointArray, centerPoint) {
            if (!centerPoint.radial) return pointArray; // origin
            const cx = centerPoint.radial * Math.cos(convertStepsToRadians(centerPoint.angular));
            const cy = centerPoint.radial * Math.sin(convertStepsToRadians(centerPoint.angular));
            return pointArray.map(p => {
              const x = p.radial * Math.cos(convertStepsToRadians(p.angular)) + cx;
              const y = p.radial * Math.sin(convertStepsToRadians(p.angular)) + cy;
              let theta = Math.atan2(y, x); if (theta < 0) theta += 2 * Math.PI;
              const r = Math.sqrt(x * x + y * y);
              return { radial: Math.round(r), angular: Math.round(fmap(theta, 0, 2 * Math.PI, 0, 2 * STEPS_PER_MOTOR_REV)) };
            });
          }

          // --- Pattern function factories (mirror firmware static vars via closure) ---
          const patternFactories = {
            1: () => { // Simple Spiral
              const angleDivisions = 100; const angleStep = convertDegreesToSteps(360 / angleDivisions);
              const radialDivisions = 10 * angleDivisions; let radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
              return (current, restart) => {
                if (restart) { radialStep = Math.trunc(MAX_R_STEPS / radialDivisions); }
                let target = { angular: current.angular + angleStep, radial: current.radial + radialStep };
                if (target.radial > MAX_R_STEPS || target.radial < 0) { radialStep *= -1; target.radial += 2 * radialStep; }
                return target;
              };
            },
            2: () => { // Cardioids
              const radialStep = Math.trunc(MAX_R_STEPS / 8); let direction = 1; let firstRun = true;
              return (current, restart) => {
                if (firstRun || restart) { firstRun = false; return { angular: 0, radial: 0 }; }
                const ang = current.angular + convertDegreesToSteps(43);
                let nextRad = current.radial + direction * radialStep; if (nextRad > MAX_R_STEPS || nextRad < 0) { direction *= -1; nextRad = current.radial + direction * radialStep; }
                return { angular: ang, radial: nextRad };
              };
            },
            3: () => { // Wavy Spiral
              const angleDivisions = 100; const angleStep = convertDegreesToSteps(360 / angleDivisions);
              const radialDivisions = 10 * angleDivisions; let radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
              const amplitude = 200; const period = 8;
              return (current, restart) => {
                if (restart) radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
                let baseRad = current.radial + radialStep; let ang = current.angular + angleStep;
                if (baseRad > MAX_R_STEPS || baseRad < 0) { radialStep *= -1; baseRad += 2 * radialStep; }
                const wave = amplitude * Math.sin(period * convertStepsToRadians(ang));
                return { angular: ang, radial: Math.round(baseRad + wave) };
              };
            },
            4: () => { // Rotating Squares
              const segments = 20; const angleShift = convertDegreesToSteps(10);
              let p1, p2, p3, p4; let step = 0; let firstRun = true; let lineIter = null;
              const makeLine = (a, b) => (lineIter = createLineIterator(a, b, segments));
              return (current, restart) => {
                if (firstRun || restart) {
                  p1 = { angular: 0, radial: 7000 }; p2 = { angular: convertDegreesToSteps(90), radial: 7000 };
                  p3 = { angular: convertDegreesToSteps(180), radial: 7000 }; p4 = { angular: convertDegreesToSteps(270), radial: 7000 };
                  step = 0; firstRun = false; lineIter = createLineIterator(p1, p2, segments);
                }
                let point = lineIter && lineIter();
                if (!point) { // finished edge
                  step++;
                  switch (step) {
                    case 1: makeLine(p2, p3); break;
                    case 2: makeLine(p3, p4); break;
                    case 3: makeLine(p4, p1); break;
                    default:
                      // rotate and restart
                      step = 0; p1.angular += angleShift; p2.angular += angleShift; p3.angular += angleShift; p4.angular += angleShift; makeLine(p1, p2); break;
                  }
                  point = lineIter();
                }
                return point;
              };
            },
            5: () => { // Pentagon Spiral
              const vertices = 5; let vertexList = []; let start = 0, end = 1; let firstRun = true; let radialStepover = 500; let lineIter = null;
              const rebuildLine = () => { lineIter = createLineIterator(vertexList[start], vertexList[end], 100); };
              return (current, restart) => {
                if (firstRun || restart) { vertexList = nGonGenerator(vertices, 1000, 0); firstRun = false; start = 0; end = 1; radialStepover = 500; rebuildLine(); }
                let point = lineIter();
                if (!point) { // edge complete
                  start = (start + 1) % vertices; end = (end + 1) % vertices;
                  if (start === 0 && end === 1) { // completed polygon, adjust radii
                    for (let i = 0; i < vertices; i++) {
                      let newR = vertexList[i].radial + radialStepover; if (newR > MAX_R_STEPS || newR < 0) { radialStepover *= -1; newR += 2 * radialStepover; }
                      vertexList[i].radial = newR;
                    }
                  }
                  rebuildLine(); point = lineIter();
                }
                return point;
              };
            },
            6: () => { // Hexagon Vortex
              const vertices = 6; let step = 0; let segments = 100; let firstRun = true; let radialStepover = 350; let radius = 1000; const angleShift = convertDegreesToSteps(5);
              let points = []; let lineIter = null; let idxEdge = 0;
              const rebuildHex = () => { points = nGonGenerator(vertices, radius, 0); };
              const startEdge = () => { const a = points[idxEdge]; const b = points[(idxEdge + 1) % vertices]; lineIter = createLineIterator(a, b, segments); };
              return (current, restart) => {
                if (firstRun || restart) { firstRun = false; step = 0; radius = 1000; radialStepover = 350; idxEdge = 0; rebuildHex(); startEdge(); }
                let pt = lineIter();
                if (!pt) { // move to next edge or rotate/resize
                  idxEdge++;
                  if (idxEdge >= vertices) { // hex complete
                    idxEdge = 0; // rotate
                    for (const p of points) p.angular += angleShift;
                    if ((radius + radialStepover >= MAX_R_STEPS + 2000) || (radius + radialStepover <= 0)) radialStepover *= -1;
                    radius += radialStepover; for (const p of points) p.radial = radius;
                  }
                  startEdge(); pt = lineIter();
                }
                return pt;
              };
            },
            7: () => { // Pentagon Rainbow
              const vertices = 5; const shiftDeg = 2; const baseRadius = 3000; const translateRadius = 4000; let firstRun = true; let shiftCounter = 1; let pointList = []; let start = 0, end = 1; let lineIter = null;
              const rebuildPent = () => {
                pointList = nGonGenerator(vertices, baseRadius, shiftCounter * shiftDeg);
                pointList = translatePoints(pointList, { radial: translateRadius, angular: shiftCounter * convertDegreesToSteps(shiftDeg) });
                start = 0; end = 1; lineIter = createLineIterator(pointList[start], pointList[end], 100);
              };
              return (current, restart) => {
                if (firstRun || restart) { firstRun = false; shiftCounter = 1; rebuildPent(); }
                let pt = lineIter();
                if (!pt) {
                  start = (start + 1) % vertices; end = (end + 1) % vertices;
                  if (start === 0 && end === 1) { shiftCounter++; rebuildPent(); pt = lineIter(); } else { lineIter = createLineIterator(pointList[start], pointList[end], 100); pt = lineIter(); }
                }
                return pt;
              };
            },
            8: () => { // Random Walk 1 (random absolute targets)
              return (current, restart) => {
                if (restart) return { angular: 0, radial: 0 };
                return { angular: Math.floor(Math.random() * STEPS_PER_A_AXIS_REV), radial: Math.floor(Math.random() * (MAX_R_STEPS + 1)) };
              };
            },
            9: () => { // Random Walk 2 (straight lines between random points)
              let makeNew = true; let randomPoint = null; let lastPoint = null; let lineIter = null;
              return (current, restart) => {
                if (restart) { makeNew = true; lastPoint = current; }
                if (makeNew) {
                  randomPoint = { radial: Math.floor(Math.random() * (MAX_R_STEPS + 1)), angular: Math.floor(Math.random() * STEPS_PER_A_AXIS_REV) };
                  lineIter = createLineIterator(lastPoint || current, randomPoint, 100); makeNew = false;
                }
                const pt = lineIter();
                if (!pt) { makeNew = true; lastPoint = randomPoint; return lastPoint; }
                return pt;
              };
            },
            10: () => { // Accidental Butterfly
              const angleDivisions = 100; const angleStep = convertDegreesToSteps(360 / angleDivisions);
              const radialDivisions = 10 * angleDivisions; let radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
              return (current, restart) => {
                if (restart) radialStep = Math.trunc(MAX_R_STEPS / radialDivisions);
                let ang = current.angular + angleStep; let rad = current.radial + radialStep;
                if (rad > MAX_R_STEPS || rad < 0) { radialStep *= -1; rad += 2 * radialStep; }
                const rOffset = 200 * Math.sin(8 * convertStepsToRadians(ang));
                const aOffset = 40 * Math.cos(3 * convertStepsToRadians(ang)); // NOTE: firmware adds this directly in steps (not degrees)
                // Firmware logic: target.radial += rOffset; target.angular += aOffset; where aOffset amplitude is 40 steps.
                return { radial: Math.round(rad + rOffset), angular: Math.round(ang + aOffset) };
              };
            },
            11: () => { // Custom DSL Script (units radius: cm, angle: degrees, rev continuous)
              const stepsPerRev = STEPS_PER_A_AXIS_REV;
              const degToSteps = stepsPerRev / 360;
              const maxRadiusCm = this.scriptMaxRadius;
              const stepsPerCm = MAX_R_STEPS / maxRadiusCm;
              // Reset rev tracking on new factory creation
              this.revPrevAngleDeg = null; this.revUnwrappedAngleDeg = 0;
              return (current, restart) => {
                if (!this.compiledScript) return current;
                const currentRadiusCm = current.radial / stepsPerCm;
                const currentAngleDeg = (current.angular / stepsPerRev) * 360;
                // Update continuous revolution accumulator
                if (restart || this.revPrevAngleDeg == null) {
                  this.revPrevAngleDeg = currentAngleDeg; this.revUnwrappedAngleDeg = currentAngleDeg; // start from actual
                } else {
                  let delta = currentAngleDeg - this.revPrevAngleDeg;
                  if (delta > 180) delta -= 360; else if (delta < -180) delta += 360; // shortest path
                  this.revUnwrappedAngleDeg += delta;
                  this.revPrevAngleDeg = currentAngleDeg;
                }
                const rev = this.revUnwrappedAngleDeg / 360;
                const vars = { radius: currentRadiusCm, angle: currentAngleDeg, start: restart ? 1 : 0, rev };
                const values = evalDSLCompiled(this.compiledScript, vars);
                function has(v){ return v!=null && isFinite(v); }
                let outRadiusCm = currentRadiusCm;
                if (has(values.next_radius)) outRadiusCm = values.next_radius; else if (has(values.delta_radius)) outRadiusCm = currentRadiusCm + values.delta_radius;
                let outAngleDeg = currentAngleDeg;
                if (has(values.next_angle)) outAngleDeg = values.next_angle; else if (has(values.delta_angle)) outAngleDeg = currentAngleDeg + values.delta_angle;
                outRadiusCm = Math.max(0, Math.min(maxRadiusCm, outRadiusCm));
                outAngleDeg = ((outAngleDeg % 360) + 360) % 360;
                const radialSteps = Math.round(outRadiusCm * stepsPerCm);
                const angleSteps = Math.round(outAngleDeg * degToSteps) % stepsPerRev;
                return { radial: radialSteps, angular: angleSteps };
              };
            }
          };

          // --- Simulation driver ---
          const factory = patternFactories[id]; if (!factory) return [];
          const stepFn = factory();
          const targetPoints = this.patternMeta[id - 1]?.pointsTarget || 2000;
          let current = { radial: 0, angular: 0 }; let restart = true; const pts = [];
          let safety = targetPoints * 4; // guardrail halt
          while (pts.length < targetPoints && safety-- > 0) {
            const target = stepFn(current, restart);
            restart = false;
            // orchestrateMotion simplified effect: final position equals target (angle wrapped)
            current = {
              radial: Math.max(0, Math.min(MAX_R_STEPS, target.radial)),
              angular: modulus(target.angular, STEPS_PER_A_AXIS_REV)
            };
            const xy = polarToXY(current.radial, current.angular);
            pts.push(xy);
          }
          return pts;
        }
      }
    }

    // Simple debounce helper
    function debounce(fn, wait) {
      let t; return function (...args) { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), wait); };
    }

    // -------- DSL Compiler & Evaluator (Unified) --------
    const DSG_OP = { CONST:'CONST', LOAD:'LOAD', ADD:'ADD', SUB:'SUB', MUL:'MUL', DIV:'DIV', NEG:'NEG', SIN:'SIN', COS:'COS', ABS:'ABS', CLAMP:'CLAMP', SIGN:'SIGN', END:'END' };
  // Added 'rev' synthetic input (angle/360) for revolution-based patterns.
  const DSG_INPUTS = ['radius','angle','start','rev'];
    const DSG_OUTPUTS = ['next_radius','next_angle','delta_radius','delta_angle'];
    const DSG_FUNCS = { sin:1, cos:1, abs:1, clamp:3, sign:1 };
  const DSG_CONSTS = { };

    function tokenizeDSL(source){
      const lines=source.replace(/\r\n?/g,'\n').split(/\n/); const tokens=[]; let global=0; const errors=[];
      const push=(type,value,pos)=>tokens.push({type,value,pos});
      for(const line of lines){
        if(/^\s*#/.test(line)){ global+=line.length+1; continue; }
        let i=0; let hadCode=false;
        while(i<line.length){
          const c=line[i]; const pos=global+i;
          if(/[ \t]/.test(c)){ i++; continue; }
          if(c=='#') break;
          if(/[0-9]/.test(c)){
            let j=i+1; while(j<line.length && /[0-9]/.test(line[j])) j++; if(j<line.length && line[j]=='.'){ j++; while(j<line.length && /[0-9]/.test(line[j])) j++; }
            push('NUMBER', parseFloat(line.slice(i,j)), pos); i=j; hadCode=true; continue;
          }
          if(/[a-zA-Z_]/.test(c)){
            let j=i+1; while(j<line.length && /[a-zA-Z0-9_]/.test(line[j])) j++;
            push('IDENT', line.slice(i,j), pos); i=j; hadCode=true; continue;
          }
            if('+-*/=(),'.includes(c)){ push(c,c,pos); i++; hadCode=true; continue; }
          errors.push({message:'Unexpected char '+c,pos}); i++;
        }
        if(hadCode) push('EOL','EOL', global+line.length-1);
        global+=line.length+1;
      }
      return {tokens, errors};
    }
  function compileDSL(source){
      const {tokens, errors} = tokenizeDSL(source); if(errors.length) return {ok:false, errors};
  let idx=0; const assignments={}; const usedOrder=[]; const definedOutputs=new Set(); const localVars=new Set();
      const peek=()=>tokens[idx]; const consume=t=>{ const tk=peek(); if(!tk||tk.type!==t){ errors.push({message:'Expected '+t,pos:tk?tk.pos:-1}); return null;} idx++; return tk; };
      function parseExpression(){
        const output=[]; const stack=[]; let expectValue=true; const prec=o=>o==='+'||o==='-'?1:(o==='*'||o==='/'?2:0); const isOp=t=>['+','-','*','/'].includes(t);
        while(true){ const tk=peek(); if(!tk) break; if(tk.type==='EOL') { break; }
          if(tk.type==='NUMBER'){ output.push(tk); idx++; expectValue=false; continue; }
          if(tk.type==='IDENT'){ const next=tokens[idx+1]; if(next && next.type==='('){ stack.push(tk); idx+=2; stack.push({type:'('}); expectValue=true; continue; } output.push(tk); idx++; expectValue=false; continue; }
          if(tk.type==='('){ stack.push(tk); idx++; expectValue=true; continue; }
          if(tk.type===')'){ while(stack.length && stack[stack.length-1].type!=='('){ output.push(stack.pop()); } if(!stack.length){ errors.push({message:'Mismatched )',pos:tk.pos}); idx++; break; } stack.pop(); if(stack.length && stack[stack.length-1].type==='IDENT'){ output.push(stack.pop()); } idx++; expectValue=false; continue; }
          if(tk.type===','){ while(stack.length && stack[stack.length-1].type!=='('){ output.push(stack.pop()); } if(!stack.length){ errors.push({message:'Misplaced comma',pos:tk.pos}); } idx++; expectValue=true; continue; }
          if(isOp(tk.type)){ let op=tk.type; if(op==='-' && expectValue){ stack.push({type:'NEG',pos:tk.pos}); idx++; continue; } while(stack.length){ const top=stack[stack.length-1]; if(isOp(top.type) && prec(top.type) >= prec(op)){ output.push(stack.pop()); } else break; } stack.push(tk); idx++; expectValue=true; continue; }
          break; }
        while(stack.length){ const s=stack.pop(); if(s.type==='(') errors.push({message:'Mismatched (',pos:s.pos}); else output.push(s); }
        // consume trailing EOL(s)
        while(peek() && peek().type==='EOL') idx++;
        return output; }
  function rpnToBytecode(rpn, definedLocals){ const bc=[]; for(const tk of rpn){ if(!tk) continue; if(tk.type==='NUMBER'){ bc.push({op:DSG_OP.CONST,v:tk.value}); continue; } if(tk.type==='IDENT'){ const nm=tk.value; if(DSG_CONSTS[nm] != null){ bc.push({op:DSG_OP.CONST,v:DSG_CONSTS[nm]}); continue; } if(DSG_FUNCS[nm]!=null){ switch(nm){ case 'sin': bc.push({op:DSG_OP.SIN}); break; case 'cos': bc.push({op:DSG_OP.COS}); break; case 'abs': bc.push({op:DSG_OP.ABS}); break; case 'clamp': bc.push({op:DSG_OP.CLAMP}); break; case 'sign': bc.push({op:DSG_OP.SIGN}); break; } continue; } if(DSG_INPUTS.includes(nm)){ bc.push({op:DSG_OP.LOAD,v:nm}); continue; } if(DSG_OUTPUTS.includes(nm)){ if(!definedOutputs.has(nm)){ errors.push({message:'Output '+nm+' used before it is assigned earlier in script',pos:tk.pos}); } bc.push({op:DSG_OP.LOAD,v:nm}); continue; } if(definedLocals.has(nm)){ bc.push({op:DSG_OP.LOAD,v:nm}); continue; } errors.push({message:'Unknown identifier '+nm,pos:tk.pos}); continue; } if(['+','-','*','/'].includes(tk.type)){ bc.push({op:{'+':DSG_OP.ADD,'-':DSG_OP.SUB,'*':DSG_OP.MUL,'/':DSG_OP.DIV}[tk.type]}); continue; } if(tk.type==='NEG'){ bc.push({op:DSG_OP.NEG}); continue; } } bc.push({op:DSG_OP.END}); return bc; }
      while(idx < tokens.length && !errors.length){
        // skip stray EOLs
        while(peek() && peek().type==='EOL') idx++;
        const lhs=peek(); if(!lhs) break;
        if(lhs.type==='IDENT'){
          const name=lhs.value; idx++;
            if(!consume('=')) break;
            const rpn=parseExpression();
            const bc=rpnToBytecode(rpn, localVars);
            if(DSG_OUTPUTS.includes(name)){
              assignments[name]=bc; if(!usedOrder.includes(name)) usedOrder.push(name); definedOutputs.add(name);
            } else if(DSG_INPUTS.includes(name)) {
              errors.push({message:'Cannot assign to read-only input '+name,pos:lhs.pos}); break; }
            else {
              assignments[name]=bc; if(!usedOrder.includes(name)) usedOrder.push(name); localVars.add(name);
            }
        } else {
          errors.push({message:'Unexpected token',pos:lhs.pos}); break;
        }
      }
      if(!usedOrder.length && !errors.length) errors.push({message:'No assignments found',pos:0}); if(errors.length) return {ok:false, errors}; return {ok:true, script:{assignments, used:usedOrder, locals:[...localVars]}}; }
    function evalDSLCompiled(compiled, baseVars){
      // Evaluate in source order so later outputs can reference earlier outputs.
      const env = { ...baseVars }; const out={};
      function run(bc){
        const st=[];
        for(const ins of bc){
          switch(ins.op){
            case DSG_OP.CONST: st.push(ins.v); break;
            case DSG_OP.LOAD: st.push(env[ins.v] ?? 0); break;
            case DSG_OP.ADD: { const b=st.pop(), a=st.pop(); st.push(a+b); break; }
            case DSG_OP.SUB: { const b=st.pop(), a=st.pop(); st.push(a-b); break; }
            case DSG_OP.MUL: { const b=st.pop(), a=st.pop(); st.push(a*b); break; }
            case DSG_OP.DIV: { const b=st.pop(), a=st.pop(); st.push(b===0?0:a/b); break; }
            case DSG_OP.NEG: { const a=st.pop(); st.push(-a); break; }
            case DSG_OP.SIN: { const a=st.pop(); st.push(Math.sin(a * Math.PI / 180)); break; } // degree-based
            case DSG_OP.COS: { const a=st.pop(); st.push(Math.cos(a * Math.PI / 180)); break; } // degree-based
            case DSG_OP.ABS: { const a=st.pop(); st.push(Math.abs(a)); break; }
            case DSG_OP.CLAMP: { const c=st.pop(), b=st.pop(), a=st.pop(); st.push(Math.min(Math.max(a,b),c)); break; }
            case DSG_OP.SIGN: { const a=st.pop(); st.push(a>0?1:(a<0?-1:0)); break; }
            case DSG_OP.END: return st.pop() || 0;
          }
        }
        return 0;
      }
      for(const name of compiled.used){
        const val = run(compiled.assignments[name]);
        out[name] = val; env[name] = val; // expose to subsequent expressions
      }
      return out;
    }
    function formatBytecodeListing(bc){ return bc.map(ins=>{ if(ins.v!=null) return ins.op+' '+ins.v; return ins.op; }).join('\n'); }

    document.addEventListener('alpine:init', () => {
      const orig = sandGardenApp; window.sandGardenApp = function(){ const base = orig(); return Object.assign(base, {
        formatBytecode(bc){ return formatBytecodeListing(bc); },
        loadExample(ex){ this.scriptSource = ex.code; if(this.autoRecompile){ this.compileScript(); if(this.autoSimulate) this.simulateScript(); } },
        compileScript(){ const res=compileDSL(this.scriptSource); if(!res.ok){ this.compileErrors=res.errors.map(e=>({message:enhanceErrorMessage(e.message), pos:e.pos})); this.compiledScript=null; } else { this.compileErrors=[]; this.compiledScript=res.script; if(this.autoSimulate) this.simulateScript(); } },
        useScriptPattern(){ if(!this.compiledScript) return; this.pattern=11; this.setStatus('Using custom script'); this.regeneratePattern(); },
        simulateScript(){ if(!this.compiledScript){ this.setStatus('Compile first'); return; } if(this.pattern!==11) this.pattern=11; this.regeneratePattern(); },
  evalCompiledScript(current, startFlag, MAX_R_STEPS, STEPS_PER_A_AXIS_REV){
    // Standalone evaluator variant (mirrors factory 11 logic) for preview mode.
    if(!this.compiledScript) return current;
    const stepsPerRev = STEPS_PER_A_AXIS_REV;
    const degToSteps = stepsPerRev / 360;
    const maxRadiusCm = this.scriptMaxRadius;
    const stepsPerCm = MAX_R_STEPS / maxRadiusCm;
    const currentRadiusCm = current.radial / stepsPerCm;
    const currentAngleDeg = (current.angular / stepsPerRev) * 360;
    // Continuous rev tracking (unwrapped angle)
    if(startFlag || this.revPrevAngleDeg == null){
      this.revPrevAngleDeg = currentAngleDeg;
      this.revUnwrappedAngleDeg = currentAngleDeg; // start from actual angle (prevents jump if not zero)
    } else {
      let delta = currentAngleDeg - this.revPrevAngleDeg;
      if(delta > 180) delta -= 360; else if(delta < -180) delta += 360;
      this.revUnwrappedAngleDeg += delta;
      this.revPrevAngleDeg = currentAngleDeg;
    }
    const rev = this.revUnwrappedAngleDeg / 360;
    const vars = { radius: currentRadiusCm, angle: currentAngleDeg, start: startFlag?1:0, rev };
    const values = evalDSLCompiled(this.compiledScript, vars);
    function has(v){ return v!=null && isFinite(v); }
    let outRadiusCm = currentRadiusCm;
    if(has(values.next_radius)) outRadiusCm = values.next_radius; else if(has(values.delta_radius)) outRadiusCm = currentRadiusCm + values.delta_radius;
    let outAngleDeg = currentAngleDeg;
    if(has(values.next_angle)) outAngleDeg = values.next_angle; else if(has(values.delta_angle)) outAngleDeg = currentAngleDeg + values.delta_angle;
    // Mirror mode: reflect angle every other revolution (odd rev index flips direction across revolution midpoint)
    if(this.mirrorMode){
      const revIndex = Math.floor(vars.rev);
      if(revIndex % 2 === 1){
        const revStart = revIndex * 360;
        const offset = outAngleDeg - revStart;
        outAngleDeg = revStart + (360 - offset);
      }
    }
    outRadiusCm = Math.max(0, Math.min(maxRadiusCm, outRadiusCm));
    outAngleDeg = ((outAngleDeg % 360)+360)%360;
    const radialSteps = Math.round(outRadiusCm * stepsPerCm);
    const angleSteps = Math.round(outAngleDeg * degToSteps) % stepsPerRev;
    return { radial: radialSteps, angular: angleSteps };
  }
      }); };
    });

    function enhanceErrorMessage(msg){
      if(/used before it is assigned/.test(msg)) return msg + ' (move its assignment above or reference the input variable instead).';
      if(/Invalid assignment target/.test(msg)) return msg + ' (allowed: next_radius, next_angle, delta_radius, delta_angle).';
      return msg;
    }
  </script>
</body>

</html>